# 2020-04

## 01

### [反変性インタフェースと共変性インタフェース　in C\# \- Qiita](https://qiita.com/h-hata/items/636f61822b89024e43a5)


共変性と反変性とは、特定の状況下 (引数や総称型、戻り値など) において、型を狭いものから広いものの順に順序づけたとき、それらの間に互換性すなわち同等性があることをいう。

[共変性と反変性 \(計算機科学\) \- Wikipedia](https://ja.wikipedia.org/wiki/%E5%85%B1%E5%A4%89%E6%80%A7%E3%81%A8%E5%8F%8D%E5%A4%89%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6))


参考にした記事では、共変性、反変性は、ある型を持つ変数へ別の型を持つインターフェースを実装したオブジェクトをだ代入できるかどうかの性質とある。

共変性と反変性のことがわからないとこの記事は理解できない。

## 02

### [Taskを極めろ！async/await完全攻略 \- Qiita](https://qiita.com/acple@github/items/8f63aacb13de9954c5da)

Taskは非同期処理に使われるが、非同期処理のことではない。

Taskは作業単位や仕事を表す。

タスクを作成するには主に`Task.Run`を使用する。

```C#
var task = Task.Run(() =>
{
    MethodA();
    MethodB();
});
```

この変数taskはMethodAを実行後、MethodBを実行するタスクを作成し、それを開始したものを表す。つまり、変数taskの中身は、文字通りタスクそのもの。

例：　1000ミリ秒待機する仕事

```c#
var task = Task.Delay(1000); // ただのDelayなんだけど、ちょっと違って見えてきません？
```

async/awaitキーワード

シグネチャにasyncを付けたメソッドを非同期メソッドと呼び、非同期メソッドで、awaitキーワードを使うことができる。awaitキーワードは指定したTaskの完了を待ち、その結果を取りだす。戻り値は必ずP`Task/Task<T>`になる。

つまり、非同期メソッドは複数のタスクをの実行順序などを記述した一つのタスクのこと、いわゆる作業手順表のようなもの。

Taskは作業手順表みたいなものだと理解できれば現状は十分かな？

## 03

### [4歳娘「パパ、20歳以上のユーザーを抽出して？」 \- Qiita](https://qiita.com/Yametaro/items/80c819054a8dca1fdb5d)

使用言語：Javascript

```js
const family = {
    mother: {
        name: "よめ太郎",
        age: 35
    },
    father: {
        name: "やめ太郎",
        age: 37
    },
    daughter: {
        name: "娘ちゃん",
        age: 4
    }
};
```

上記のオブジェクトから20歳以上のものを抽出する

例1

```js
const otona = {};

Object.keys(family).forEach(key => {
    const person = family[key];

    if (person.age >= 20) {
        otona[key] = person;
    }
});
```

otonaという名の空オブジェクトを作りfamilyオブジェクトから20歳以上のものを詰める。

Object.keys(family)を使い、familyオブジェクトのkey名を配列として取得する。

```js
["mother", "father", "daughter"].forEach(key => {
    // keyには "mother" か "father" か "daughter" が入ってくる。
    const person = family[key];

    if (person.age >= 20) {
        otona[key] = person;
    }
});
```

例2

```js
const otona =
    Object.fromEntries(
        Object.entries(family)
            .filter(([, person]) => person.age >= 20)
    );
```

Object.entries()はオブジェクトから配列をつくることができる。

```js
[
    ["mother", { name: "よめ太郎", age: 35 }],
    ["father", { name: "やめ太郎", age: 37 }],
    ["daughter", { name: "娘ちゃん", age: 4 }],
]
```

Object.fromEntriesは配列をオブジェクトに渡す。

```js
const obj = Object.fromEntries(
        Object.entries(family)
    );
```

上記で変数objにfamilyそのままのオブジェクトが入る

一度配列にすることで、配列の持っているfilter()やmap()などが使えるようになる。

```js
Object.entries(family)
    .filter(([, person]) => person.age >= 20)
```

上記で20歳以上が入った配列ができ

```js
[
    ["mother", { name: "よめ太郎", age: 35 }],
    ["father", { name: "やめ太郎", age: 37 }],
]
```

オブジェクトに戻すと

```js
{
    mother: {
        name: "よめ太郎",
        age: 35
    },
    father: {
        name: "やめ太郎",
        age: 37
    }
};
```

こんなオブジェクトができる。