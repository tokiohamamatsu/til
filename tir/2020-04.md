# 2020-04

## 01

### [反変性インタフェースと共変性インタフェース　in C\# \- Qiita](https://qiita.com/h-hata/items/636f61822b89024e43a5)


共変性と反変性とは、特定の状況下 (引数や総称型、戻り値など) において、型を狭いものから広いものの順に順序づけたとき、それらの間に互換性すなわち同等性があることをいう。

[共変性と反変性 \(計算機科学\) \- Wikipedia](https://ja.wikipedia.org/wiki/%E5%85%B1%E5%A4%89%E6%80%A7%E3%81%A8%E5%8F%8D%E5%A4%89%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6))


参考にした記事では、共変性、反変性は、ある型を持つ変数へ別の型を持つインターフェースを実装したオブジェクトをだ代入できるかどうかの性質とある。

共変性と反変性のことがわからないとこの記事は理解できない。

## 02

### [Taskを極めろ！async/await完全攻略 \- Qiita](https://qiita.com/acple@github/items/8f63aacb13de9954c5da)

Taskは非同期処理に使われるが、非同期処理のことではない。

Taskは作業単位や仕事を表す。

タスクを作成するには主に`Task.Run`を使用する。

```C#
var task = Task.Run(() =>
{
    MethodA();
    MethodB();
});
```

この変数taskはMethodAを実行後、MethodBを実行するタスクを作成し、それを開始したものを表す。つまり、変数taskの中身は、文字通りタスクそのもの。

例：　1000ミリ秒待機する仕事

```c#
var task = Task.Delay(1000); // ただのDelayなんだけど、ちょっと違って見えてきません？
```

async/awaitキーワード

シグネチャにasyncを付けたメソッドを非同期メソッドと呼び、非同期メソッドで、awaitキーワードを使うことができる。awaitキーワードは指定したTaskの完了を待ち、その結果を取りだす。戻り値は必ずP`Task/Task<T>`になる。

つまり、非同期メソッドは複数のタスクをの実行順序などを記述した一つのタスクのこと、いわゆる作業手順表のようなもの。

Taskは作業手順表みたいなものだと理解できれば現状は十分かな？

## 03

### [4歳娘「パパ、20歳以上のユーザーを抽出して？」 \- Qiita](https://qiita.com/Yametaro/items/80c819054a8dca1fdb5d)

使用言語：Javascript

```js
const family = {
    mother: {
        name: "よめ太郎",
        age: 35
    },
    father: {
        name: "やめ太郎",
        age: 37
    },
    daughter: {
        name: "娘ちゃん",
        age: 4
    }
};
```

上記のオブジェクトから20歳以上のものを抽出する

例1

```js
const otona = {};

Object.keys(family).forEach(key => {
    const person = family[key];

    if (person.age >= 20) {
        otona[key] = person;
    }
});
```

otonaという名の空オブジェクトを作りfamilyオブジェクトから20歳以上のものを詰める。

Object.keys(family)を使い、familyオブジェクトのkey名を配列として取得する。

```js
["mother", "father", "daughter"].forEach(key => {
    // keyには "mother" か "father" か "daughter" が入ってくる。
    const person = family[key];

    if (person.age >= 20) {
        otona[key] = person;
    }
});
```

例2

```js
const otona =
    Object.fromEntries(
        Object.entries(family)
            .filter(([, person]) => person.age >= 20)
    );
```

Object.entries()はオブジェクトから配列をつくることができる。

```js
[
    ["mother", { name: "よめ太郎", age: 35 }],
    ["father", { name: "やめ太郎", age: 37 }],
    ["daughter", { name: "娘ちゃん", age: 4 }],
]
```

Object.fromEntriesは配列をオブジェクトに渡す。

```js
const obj = Object.fromEntries(
        Object.entries(family)
    );
```

上記で変数objにfamilyそのままのオブジェクトが入る

一度配列にすることで、配列の持っているfilter()やmap()などが使えるようになる。

```js
Object.entries(family)
    .filter(([, person]) => person.age >= 20)
```

上記で20歳以上が入った配列ができ

```js
[
    ["mother", { name: "よめ太郎", age: 35 }],
    ["father", { name: "やめ太郎", age: 37 }],
]
```

オブジェクトに戻すと

```js
{
    mother: {
        name: "よめ太郎",
        age: 35
    },
    father: {
        name: "やめ太郎",
        age: 37
    }
};
```

こんなオブジェクトができる。

## 06

### [Vue\.jsの双方向バインディング再入門 \- Qiita](https://qiita.com/fruitriin/items/dc75af413da3661f9e78)

v-modelはv-bind:value="hoge"とv-on:input="hoge=$event.target.value"のシンタックスシュガー。


Vueのdataメソッドが返す各プロパティは、observerによってラップされており、これが、中の値の変更をキャッチし、v-bindやcomputed,watchedのトリガーとなり、伝搬する。このため、Objectにキー名を指定して新しいプロパティを生やしたり、配列を添え字指定して、配列長を延長しながら、代入するとobserverにラップしてもらうことができず、データの変更が反映されない。

コンソールでオブジェクトを見ると生のオブジェクトではなくobserverにラップされているのが確認できる。

つまり、v-modelはobserverがdataの変更を感知し、v-bind(v-model)しているプロパティに代入を行い、inputやchangeイベント(これらブラウザJSの標準イベント)でフォームの値が変化を感知し、dataに代入を行なう。

## 07

### [ワイ「なに！？型のズレを吸収できるやと！？」 \- Qiita](https://qiita.com/Yametaro/items/af7dde38c6523dba110c)

使用言語：Javascript

オブジェクトと配列が混じっている場合

```js
const family = {
    mother: {
        name: "よめ太郎",
        age: 35
    },
    father: {
        name: "やめ太郎",
        age: 37
    },
    children: [
        {
            name: "娘ちゃん",
            age: 4
        },
        {
            name: "ボブ",
            age: 39
        }
    ]
};
```

上記からageが20以上のものを取り出した配列を作る

object.valuesを使い配列を作る。

```js
const familyArray =
    Object.values(family)
```

object.valuesはオブジェクトのkey名は使わずにvalueだけ取り出し、配列を作ってくれる

familyArrayの中身
```js
[
    { name: "よめ太郎", age: 35 },
    { name: "やめ太郎", age: 37 },
    [
        { name: "娘ちゃん", age: 4 },
        { name: "ボブ", age: 39 }
    ]
]
```

配列のflatメソッドを使いネストした配列から1段階フラットな配列を作る

```js
const flatFamilyArray =
    familyArray.flat()
```

実行結果

```js
[
    { name: "よめ太郎", age: 35 },
    { name: "やめ太郎", age: 37 },
    { name: "娘ちゃん", age: 4 },
    { name: "ボブ", age: 39 }
]
```

あとはfilterを使い

```js
const otonaArray =
    Object.values(family)
        .flat()
        .filter(person => person.age >= 20);
```

こうすることで、ageが20以上のものを取り出した配列ができる。

```js
[3].flat() // -> [3]

[[3]].flat() // -> [3]
```

上記の例で元の値が3であろうと`[3]`であろうと1度[]で包んでflat()すれば同じ`[3]`になる。

こうすることで型を合わせられる。