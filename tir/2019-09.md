# 2019-09

## 02

### [Vue\.js \- コンポーネントとイベントハンドラの動的交換を、 v\-ifを使わず実装する \- Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

ifを使わずコンポーネントを動的に切り替え、コンポーネントごとにイベントハンドリングの方法を変更する

```html
<div id="app">
  <h2>switch component and event handler:</h2>
  <ul>
    <li>
      <input type="radio" name="mapping" value="hoge" @input="onSelect"> hoge
    </li>
    <li>
      <input type="radio" name="mapping" value="fuga" @input="onSelect"> fuga
    </li>
    <li>
      <input type="radio" name="mapping" value="piyo" @input="onSelect"> piyo
    </li>
  </ul>
  <component :is="current.component" @click="onClick"></component>
</div>
```

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
const fuga = {
  component: Vue.extend({
    template: '<button @click="onClick">fuga</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('fuga')
  }
}
const piyo = {
  component: Vue.extend({
    template: '<button @click="onClick">piyo</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('piyo')
  }
}

new Vue({
  el: "#app",
  data: {
    current: hoge,
  },
  computed: {
    viewModelMap: function () {
        return {
        hoge, fuga, piyo
      }
    }
  },
  methods: {
    onClick: function () {
      this.current.onClick()
    },
    onSelect: function (event) {
      const viewModelKey = event.target.value

      this.mapping(viewModelKey)
    },
    mapping: function (viewModelKey) {
      const viewModel = this.viewModelMap[viewModelKey]

      if (!viewModel) {
        return
      }

      this.current = this.viewModelMap[viewModelKey]    
    }
  }
})
```

- `:is`プロパティ
  componentタグと合わせて、動的にコンポーネントを切り替える機能。`is`に指定されたタグかVueコンポーネントが作画される。
  `is`にはコンポーネント名やオプションオブジェクトの他`VueConstructor`を渡してもいい

- コンポーネント イベントハンドリングの対応関係をオブジェクト化

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
```

効果

- 子コンポーネントがシンプルかつステートレスに保てる
- パターンが増えたら、子コンポーネント イベントハンドリングの対応オブジェクトを追加するだけ
- 子コンポーネントだけ/イベントハンドリングの方法だけ、という単位で交換可能、個々の実装は変更不要

>「イベントハンドリングの内容」として 
 A\. コンポーネント依存の処理 
 B\. コンポーネント非依存の処理 
  という分別が存在し得ることを、明示的に認識していなかったからと思われる。  Aについては、それはコンポーネント自身に関わることであるから、自身の内部にその内容が記述されるべきだと思う（オブジェクトの状態を変更する場合に、setterを定義せず、内部にその手続きを閉じ込めるのと同じ）（まあ普段は新しいオブジェクトを作っちゃうけど、ここでは「変更しないといけない」ということで）。 これが外部に引き剥がされてしまうのと、それはコンポーネントに関する知識がコンポーネントの外部に流出してしまうことになるので、好ましくない。
 一方、Bはそもそもコンポーネント非依存なのだから、コンポーネントからは独立した状態 = 別モジュールとして定義/実装されているはず。 元々コンポーネントからは引き剥がされているのだから、それの呼び出し方が外部化されたとしてもそれは一枚層が増えただけで、状況は変わっていない。
>[Vue.js - コンポーネントとイベントハンドラの動的交換を、 v-ifを使わず実装する - Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

オブジェクト化すれば後々楽になる

## 03

### [vee\-validate で「特定のフィールドに固有のバリデーションメッセージを設定する \- Qiita](https://qiita.com/ishiyama0530/items/106dfebe95165431f9e2)

特定のフィールドで、他の検証ルールに影響をあたえず、特定の検証ルールにのみバリデーションメッセージを設定する

lib/validatormessage

```js 
import { Validator } from 'vee-validate';

export function getError(
    validator: Validator,
    field: string,
    ruleMsssageMap: { [rule: string]: string }
): string | null {
    const errors = validator.errors.items.filter((e) => e.field === field);
    if (errors.length > 0) {
        const error = errors[0];
        let isExists = false;
        for (const rule in ruleMsssageMap) {
            if (error.rule === rule) {
                isExists = true;
            }
        }

        if (isExists) {
            return ruleMsssageMap[error.rule];
        } else {
            return validator.errors.first(field);
        }
    }

    return null;
}
```

```js
<template>
  <input
    type="text"
    name="myfield"
    v-model="myfieldValue"
    v-validate="{ required: true, regex: /[1-9]/ }"
  />
  <div v-show="myfieldError">
    {{ myfieldError  }}
  </div>
</template>
<script lang="ts">
import { getError } from '@lib/validatormessage'
...
computed: {
    myfieldError: {
      get: (): string | null => {
        return getError(this.$validator, 'myfield' { regex: 'cutome error message.' })
      },
    },
  },
<script>
```

myfieldErrorはバインドされており、変更された時、算出プロパティであるmyfieldErrorのget()が実行され、`lib/validatormessage`でエラー起きたruleと同じruleを探しメッセージを置き換える

## 04

### [Laravelでキャッシュクリアできず\.envを反映できない時の対応方法 \- Qiita](https://qiita.com/ponsuke0531/items/1a665c68d12a74a29a42)

`.env`でDBの設定を変更したが、キャッシュクリアがでできず、`.env`の設定が反映されない

storageディレクトリにあるキャッシュ用ディレクトリの中身を削除

```
# storageディレクトリにあるキャッシュのディレクトリを確認する
$ cat config/cache.php | grep storage_path | grep framework
            'path' => storage_path('framework/cache/data'),

# 中身を全削除する
$ rm storage/framework/cache/data/*

# 事象は何も変わらなかった
$ php artisan cache:clear

In  Oci8.phpline 464:

  ORA-01017: ユーザー名/パスワードが無効です。ログオンは拒否されました。
```

削除するキャッシュのファイルが違うため事象は変わらなかった

>\.env ファイルの読み込みは， php artisan config:cache していない場合にしか行われません！ キャッシュを有効にしてある場合， \.env に書いてあるだけでシェルから起動する時点で定義されていない環境変数はすべて未定義になってしまうので注意しましょう。
>[[Laravel] Laravel では env() を config 系ファイル以外の場所に書いてはいけない - mpyw's tech blog](https://mpyw.qrunch.io/entries/nyuqLPQzA2ej0Bo1)

>設定ファイルのキャッシュを止めることはできません。あなたがする必要がある唯一のことはconfig：cacheを呼ばないことです。 ファイル自体はbootstrap / cache / config\.phpにあります。
>[laravel-5 – Laravel 5が設定をキャッシュしないようにする方法 - コードログ](https://codeday.me/jp/qa/20190119/154959.html)

対処法 bootstrap/cache/config.phpを削除する

```
# config.phpを削除する
$ rm bootstrap/cache/config.php
# うまく行った!
$ php artisan config:clear
Configuration cache cleared!
```

DBの設定には気をつけよう

## 05

### [Laravel 6\.0 アップデートメモ \- Qiita](https://qiita.com/a_yasui/items/12d3b2d6ac2f29d364c9)

Laravel6 が2019/09/04にリリースされた。このバージョンからバージョン番号にsemverが採用され、しれっと新しい機能が追加されても追いかけられるようなった

追加点と変更点
- Authorized Resources & viewAny
  Controller Helperにて、Policy Method `viewAny`が追加され、それに対応したController Method側には`index`が追加された。すでに`index`メソッドがある場合呼ばれなくなる
- Laravel Helperにあった関数`str_`や`array_`が新しいlaravel/helpers パッケージに移った。今まで通りに使うには`composer require laravel/helpers`を実行する
- Facade/Ignition
  開発環境時のエラーメッセージに`lgnition`が採用された
- Improved Authorization Responses
  認証時メッセージを簡単に変更できるようになった
- Job Middleware
  JobにMiddlewareを被せれるようになった
- Laravel UI
Laravelのjsまわりが分離され,laravel/uiになった
- PHP 7.2 Required
  php7.1以下は非推奨になり、2019/12/1にサポートが切れる
- Authentication RegisterController
  RegisterControllerに変更があり、`RegisterController`の小クラスで`registerd`や`regidter`メソッドをしている時、親クラスの`registered`メソッドでユーザーの追加やイベントの発火などをしているため、`parent::registered()`や`parent::register` を呼び出さないとユーザーの新規登録に失敗する。
- Carbon 1.x No Longer Supported
  Cardon 1.x が打ち切られるので、Cardon2にアップグレードする
- Eloquent Arrayable & toArray
  Eloquentの`toAttay`メソッドの返り値が`Illuminate\Contracts\Support\Arrayable `を実装する属性を普通の配列(array)にキャストするようになる
- Eloquent BelongsTo::update Method
  `$model->user()->update([]);`の場合eventが発生するが、`$model->user->update([]);`の場合でとeventが発生しない
- Eloquent Primary Key Types
  Primary Keyはint/bigintだけだったが、stringにも対応できるようになる
- Localization Lang::getFromJson Method
  Lang::getとLang::getFromJsonが統合された。Lang::getFromJsonを呼んでいる部分は、Lang::getを呼び出すように変更する
- Queue Retry Limit
  php artisan queue:workにおいてlaravel６では1回失敗したらすぐにfailedに変更される
- Resend Email Verification Route
  標準の再メール認証がGet Requestから、Post Request + csrf 付きに変更された
- The Input Facade
  Input Facade は Request Facadeと機能が同じなので削除された。`Input::get()`は`Request::input()`に置換する

 Eloquentの変更点が多い

 ## 06

 ### [Laravel ミドルウェアの設定について \- Qiita](https://qiita.com/KZ-taran/items/a746a96b12489ae56553)

 Middlewareクラスの生成

 Middlewareクラスは`$ php artisan make:middleware {クラス名}`コマンドを実行し、`app/Http/Middleware/`にファイルを生成する。
 生成されたMiddlewareクラス内にある`handle()`に実装内容を書く
 - `$response = $next($request);`に前に実装内容を記載するか、後に記載するかでBefor MiddlewareかAfter Middlewareかを書き分けれる

Middlewareの登録

実装が完了したMiddlewareを実際に通すようにKarnel.phpに追記する

```php
<?php

namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel
{
    protected $middleware = [
        \App\Http\Middleware\TrustProxies::class,
        \App\Http\Middleware\CheckForMaintenanceMode::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        ...
    ];
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            ...
        ],

        'api' => [
            'throttle:60,1',
            'auth:api',
            ...
        ],
    ];
    protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        ...
    ];
    protected $middlewarePriority = [
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\Authenticate::class,
        ...
    ];
```

- $middleware(グローバルミドルウェア)
  アプリケーションの全HTTPリクエストで実行したいMiddlewareを書く
- $middlewareGroups(ミドルウェアグループ)
  複数のMiddlewareをまとめて登録し、短縮キーを指定する
- $routeMiddleware(ルートミドルウェア)
  Middlewareを個々に登録し、短縮キーを指定する
- $middlewarePriority
  特定の順番でMiddlewareの実行をする必要がある場合に記載順でMiddlewareを優先で実行させる。※$middleware(グローバルミドルウェア)ではないものを記載する。

Routeに対してMiddlwareを割り当てる

$middlewareGroups

webがキーの場合

```php
// 1つのルートに対してミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('web');

// 複数のルートに対してミドルウェアを指定する場合
Route::group(['middleware' => ['web']], function () {
    //
});
```

$routemiddleware

authMiddlewareを割り当てる場合

```php
// 一つのルートに対してミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('auth');

// １つのルートに対して複数のミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('auth', 'auth2');

// 複数のルートに対して１つのミドルウェアを指定する場合
Route::group(['middleware' => 'auth'], function () {
    //
});

// 複数のルートに対して複数のミドルウェアを指定する場合
Route::group(['middleware' => ['auth', 'auth2'], function () {
    //
});
```

繰り返し覚える

## 09

### [超カンタン！CSSで画像を自在に切り抜く方法 \- Qiita](https://qiita.com/Hiroyuki-Hiroyuki/items/8a3875fde5561d96f2eb)

画像アップロード

```html
<h2>トップ画像をアップ</h2>

<figure>

  <img class="rounded" src="{{ Storage::disk('s3')->url(Auth::user()->top_image_url) }}">
    <figcaption>現在のチャンネルトップ画像（編集前）</figcaption>

</figure>

<form method="POST" action="/storeTop" enctype="multipart/form-data">

  {{ csrf_field() }}

  <input type="file" name="photo" class="btn">

　<input type="submit" value="更新する？" class="button btn btn-primary">
             　
  </form>
```

画像を切り抜く

```html
<h2>トップ画像を編集</h2>

  <figure>

    <img class="rounded" src="{{ Storage::disk('s3')->url(Auth::user()->top_image_url) }}" style="width:1200px; height:200px; object-fit:cover; object-position:0% {{ $user->top_trim }}%;">
    <figcaption>現在のチャンネルトップ画像（編集済）</figcaption>

  </figure>
　　　　　　　　　　
　<form method="POST" action="/topTrim">

    <div class="form-group">
      <label>切り取る位置（高さ）を 0 ~ 100 の数値で入力</label>
        <div>
          <input type="number" name="top_trim" required>
          <div>例）画像の一番上を切り取る : 0 を入力</div>
          <div>　　画像の一番下を切り取る : 100 を入力</div>
        </div>
    </div>

    <input type="submit" value="更新する？" class="btn btn-primary">

  </form>
```

imgタグのsrc=""にアップした画像と同じパスを指定する

横に細長く切り抜きたい時,imgタグに
`style="width:1200px; height:200px; object-fit:cover; object-position:0% {{ $user->top_trim }}%;`と記載する。

width:1200px;height:200pxと、任意で表示させたい画像幅と高さが書いてある

`objekct-fit:cover`と記載することで、画像の縦横比を保持したまま。トリミングが可能となる。

`object-position:横の位置% 縦の位置%;`と追記擦れば、

- 横の位置=1番左から〇%の位置を切り取る
- 縦の位置=1番上から〇%の位置を切り取る

とすることができる。

`object-position:0% {{ $user->top_trim }}%;`

とすれば、%の前の数値を変数として、任意の値を持ってこれる

#### 参考

[1行追加でOK！CSSだけで画像をトリミングできる「object\-fit」プロパティー ](https://www.webcreatorbox.com/tech/object-fit)

cssの設定方法はこんな方法もあるんだ

## 10

### [Laravel Nuxt StripeでCheckout決済機能を実装する \- Qiita](https://qiita.com/gemetasu1103/items/c7f84d429eef8477c3dc)

Stripeのアカウント作成

こちらでアカウント作成
[Stripe: Login](https://dashboard.stripe.com/login?redirect=%2F)

StipeAPIライブラリをインストール

`composer require stripe/stripe-php`

API側の実装

vue側でクレジットカード情報を入力し、クレジット情報が正しい場合tokenが発行され、そのtokenを使用してAPI側で決済処理をする・

```php
public function pay(Request $request)
    {
        // Set your secret key: remember to change this to your live secret key in production
        // See your keys here: https://dashboard.stripe.com/account/apikeys
        Stripe::setApiKey('sk_test_XXXXXXXXXXXXXXXXXXXXXXXX');

        try {
            // Token is created using Checkout or Elements!
            // Get the payment token ID submitted by the form:
            $token = $request->input('stripeToken');
            $charge = Charge::create([
                'amount' => $request->input('amount'),
                'currency' => 'jpy',
                'description' => 'Example charge',
                'source' => $token,
            ]);
        }catch (Stripe\Error\Card $e){
            // 決済に失敗したらエラーメッセージを返す
            return response()->json([
                'success' => false,
                'errors' => $e->getMessage()
            ], 422);
        }

        $user_wallet = $this->exchange->cashExchange($request);

        return response()->json([
            'success' => true,
            'data' => $user_wallet,
            'message' => '現金からポイントに換金が完了しました'
        ], 200);

    }
```

フロント側の実装

vue-stripe-checkoutをインストール

`npm install vue-stripe-checkout@1.2.6 --save`

プラグインの作成

```js
import Vue from 'vue'
import VueStripeCheckout from 'vue-stripe-checkout'

Vue.use(VueStripeCheckout, process.env.STRIPE_PUBLIC_KEY)
```

Vueのテンプレート

クレジット決済したい画面で`<vue-strope-checkout>`

```js
<template>
  <div class="container">
    <h2 class="title is-4">クレジットで換金</h2>
    <!-- 入金額 -->
    <div class="field">
      <p class="control has-icons-left has-icons-right">
        <input
          v-model.number="amount"
          class="input is-medium"
          :class="{ 'is-danger': errors.amount }"
          type="number"
          placeholder="入金額"
        />
        <span class="icon is-small is-left">
          <i class="fas fa-yen-sign"></i>
        </span>
      </p>
      <div class="help is-danger">
        <ul v-if="errors.amount">
          <li v-for="msg in errors.amount" :key="msg">
            {{ msg }}
          </li>
        </ul>
      </div>
    </div>
    <div class="field">
      <b-field label="">
        <p>{{ current_time }} 現在</p>
      </b-field>
    </div>
    <div class="field">
      <b-field label="換金レート">
        <p>
          1000円 ⇔
          {{
            Math.floor(
              1000 *
                currency_date.credit_payment *
                currency_date.cash_rate *
                currency_date.cash_exchange
            )
          }}ポイント
        </p>
      </b-field>
    </div>
    <div class="field">
      <b-field label="購入ポイント">
        <p>
          {{
            Math.floor(
              amount *
                currency_date.credit_payment *
                currency_date.cash_rate *
                currency_date.cash_exchange
            )
          }}ポイントへ変換
        </p>
      </b-field>
    </div>

    <vue-stripe-checkout
      ref="checkoutRef"
      :name="name"
      :description="description"
      :currency="currency"
      :amount="amount"
      :locale="locale"
      :panel-label="label"
      :allow-remember-me="true"
      @done="done"
      @opened="opened"
      @closed="closed"
      @canceled="canceled"
    ></vue-stripe-checkout>

    <div class="field-button">
      <input
        class="button is-blue is-large is-fullwidth"
        value="OK"
        @click="stripeCheckout"
      />
    </div>
  </div>
</template>
```

スクリプト側

`vue-stripe-checkout`側でクレジット情報を入力し、成功したら`token`が発行されるので、API側にリクエストを投げる

```js
data() {
    return {
      name: 'Guild',
      description: 'カード情報を入力してください。',
      currency: 'JPY',
      label: 'カード支払い',
      locale: 'ja',
      amount: 0,
      current_time: this.$moment().format('YYYY/MM/DD HH:mm:ss'),
      currency_date: {},
      form: {
        user_id: '',
        currency_id: '',
        payment: 0,
        stripeToken: ''
      }
    }
  },
  async asyncData({ app, store }) {
    const { data } = await app.$axios.get(
      `/api/user/currency/${store.getters['event_info/currency']}`
    )
    return { currency_date: data.data[0] }
  },
  methods: {
    async stripeCheckout() {
      // this.$checkout.close()
      // is also available.
      // token - is the token object
      // args - is an object containing the billing and shipping address if enabled
      await this.$refs.checkoutRef.open()
    },
    async done({ token, args }) {
      // token - is the token object
      // args - is an object containing the billing and shipping address if enabled
      // do stuff...

      this.form.user_id = this.$nuxt.$auth.user.id
      this.form.currency_id = this.currencyId
      this.form.payment = this.amount
      this.form.stripeToken = token.id

      await this.$axios
        .$post('/api/user/wallet/pay', this.form)
        .then(data => {
          this.$router.push('/client/payment/thanks')
        })
        .catch(errors => {
          alert(JSON.stringify(errors))
        })
    },
    opened() {
      // do stuff
    },
    closed() {
      // do stuff
    },
    canceled() {
      // do stuff
    }
  }
```

Stripeとは

>ストライプ（英語: Stripe）とは個人や企業がインターネットを通して料金を受納する方法を提供する企業である。
>[ストライプ (企業) - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%97_(%E4%BC%81%E6%A5%AD))

Stripeというものがあるんだ

## 11

### [Vuexについてまとめ、使ってみる。 \- Qiita](https://qiita.com/hirooka0527/items/660b697d64975439f5fa)

Vuexとは

VuexはVue.jsのため作成された状態管理ライブラリ


Vuexのアーキテクチャ


StateとStore

StateはVuexでコンポーネント間でグローバルな状態を持つ単一のステートツリー、StareはStoreで管理される。
Stateはアプリケーション内で1つだけ作成され、そのため。アプリケーションが信頼できる唯一の情報源として機能する。

Mutations

VuexのStateを変更する唯一の方法はMutationsをコミットすること

```js
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 状態を変更する
      state.count++
    }
  }
})
```

Mutationsはイベントに近い概念を持ち、タイプとハンドラを持つ
上記のコードの場合`increment`がタイプ、メソッド部分を含めるとハンドラになる。
Mutationは直接呼び出すことができず下記のようにミューテーションタイプを指定しコミットすること

```js
store.commit('increment')
```

また、Mutationsは非同期な処理を書くことはできない

Action

アクションはMutationをコミットし、非同期な処理を書くことができる。

```js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
```

アクションでは、`context`オブジェクトを受け取る。`context.commit`でMutationをコミットでき`content.getter`でgetterにアクセスできる。
アクションそのものは、`store.dispatch`がトリガーとして実行する

```js
store.dispatch('increment')
```

`context.commit`を呼び出さないのはAction内で非同期な処理が記述できるから

```js
actions: {
  incrementAsync ({ commit }) {
    setTimeout(() => {
      commit('increment')
    }, 1000)
  }
}
```

Getter

Stateの状態からフィルタリングとして値を取り出すときGetterを使う

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})
```

Getterは以下のように呼び出せる

```js
store.getters.doneTodos
```

Vuexについてはこちら

https://vuex.vuejs.org/ja/


Vuexは便利そうだな

## 12

### [【jQuery => async/await】再帰で可変長の非同期処理の要求を順番に実行する \- Qiita](https://qiita.com/ant_inous/items/09c040938fd7a4a3eda8)

Promise

非同期処理を作成する胴元的存在 async/awaitを使い元をたどればこれに行き着く

```js
var sample = new Promise(function(resolve) { 
    resolve('true!');
 });
```

async

`async function(){}`という形で定義し、定義すると非同期関数となりPromiseを返す。jQueryでいうところの$.ajax()と同じように.then()で繋げられる

async関数の返り値

- return
  返り値のPromiseはresolveになる
  
- throwや例外
  返り値のPromiseはrejectになる

await

async関数の進みは、これをつけた処理の部分でいったんPromiseの結果が返されるまで待つ、だから中でPromiseを使う

JQueryのコード

```js
//jQuery $.Deferred()
var asyncTest=function(value){
    var def=$.Deferred();
    setTimeout(() => {
        def.resolve(value * 5);
    }, value * 200);
    return def.promise();
};

var order=[1,3,5,7,9];//テスト用の処理要求

var TestFunc=function(def){
    var req=order.shift();
    $.when(asyncTest(req))
        .then(
        function(data){
            console.log(data);
            if(order.length){
                TestFunc(def);
            }
            else{
                def.resolve('complete!!');
            }
        },
        function(jqXHR,textStatus,errorThrown){
            alert(textStatus+"_"+errorThrown);
            def.reject();
        }
    );
    return def.promise();
};
var def=$.Deferred();
TestFunc(def)
    .then((data) => {
    console.log(data);
});
```

async/awaitのコード

```js
//JavaScript async/await
const _asyncTest=(value) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(value * 5);
        }, value * 200);
    });
};

const _order=[1,3,5,7,9];//テスト用の処理要求

const _TestFunc = async () => {
    var req=_order.shift();
    var data = await _asyncTest(req);
    console.log(data);
    if(_order.length){
        return await _TestFunc();
    }
    else{
        return 'complete!';
    }
};

_TestFunc()
    .then((data) => {
    console.log(data);
});
```

比較すると,多少はasync,awaitの方が記述量が少ない

aysnc/awaitはBabelしないといけないのか

Babelとは

>「次世代JavaScript記法のためのコンパイラ」です。コンパイラじゃなくてトランスパイラという表現を使う人もいます。  Babelは「黒い画面」で動くツールで、これを使うと新しい文法で記述したJSファイルを変換して、古い文法で構成されたものを生成することができます。そしてそれは古い環境でも動作します。Sass/SCSS→CSSみたいな。
>[Babelを使って現代的JavaScriptを始める。（現代的JavaScriptおれおれアドベントカレンダー2017 – 01日目） | Ginpen.com](https://ginpen.com/2017/12/01/babel/)


## 13

### [PHPのunserializeでクラスプロパティに変更があった場合 \- Qiita](https://qiita.com/nishimura/items/b3996b56c1cb181c766e)

セッションにオブジェクトを保存し、クラスに変更があった場合どうなるか

unserializeとは

>unserialize\(\) は、シリアル化された変数を PHP 変数値に戻す変換を行います。
>[PHP: unserialize - Manual](https://www.php.net/manual/ja/function.unserialize.php)

foo.php
```php 
<?php
class Foo
{
    private $id;
    protected $name;
    public $attributes = [];

    public function __construct(int $id, string $name, array $attrs)
    {
        $this->id = $id;
        $this->name = $name;
        $this->attributes = $attrs;
    }
}
```

serialize.php
```php
<?php
class Foo
{
    private $id;
    protected $name;
    public $attributes = [];

    public function __construct(int $id, string $name, array $attrs)
    {
        $this->id = $id;
        $this->name = $name;
        $this->attributes = $attrs;
    }
}
```

useerialize.php
```php
<?php
error_reporting(-1);
require_once 'Foo.php';
$data = stream_get_contents(STDIN);
var_dump(unserialize($data));
```

serialize=>unserializeを実行する

```php
$ php serialize.php | php unserialize.php
/tmp/php/unserialize.php:5:
class Foo#1 (3) {
  private $id =>
  int(3)
  protected $name =>
  string(3) "foo"
  public $attributes =>
  array(2) {
    'bar' =>
    string(3) "baz"
    [0] =>
    int(7)
  }
}
```

プロパティが増えた場合

Foo1.php
```php
<?php
class Foo
{
    private $id;
    protected $name;
    public $attributes = [];
    public $opt;
    public function __construct(int $id, string $name, array $attrs, ?string $opt)
    {
        $this->id = $id;
        $this->name = $name;
        $this->attributes = $attrs;
        $this->opt = $opt;
    }
}
```

```php
$ php serialize.php | php unserialize1.php
/tmp/php/unserialize1.php:8:
class Foo#1 (4) {
  private $id =>
  int(3)
  protected $name =>
  string(3) "foo"
  public $attributes =>
  array(2) {
    'bar' =>
    string(3) "baz"
    [0] =>
    int(7)
  }
  public $opt =>
  NULL
```

増えたプロパティはnullになりそう

プロパティが減った場合、アクセス修飾子が変わった場合

Foo2.php

```php
<?php
class Foo
{
    protected $id;
    public function __construct(int $id)
    {
        $this->id = $id;
    }
}
```

```php
$ php serialize.php | php unserialize2.php
/tmp/php/unserialize2.php:8:
class Foo#1 (3) {
  protected $id =>
  int(3)
  protected $name =>
  string(3) "foo"
  public $attributes =>
  array(2) {
    'bar' =>
    string(3) "baz"
    [0] =>
    int(7)
  }
}
```

`protected`に変更した`$id`は`protected`に変更された
プロパティごと削除したものは`protected`、`public`を維持し復活する

シリアル化とはなんだ

シリアル化とは

>オブジェクトを格納するか、メモリ、データベース、またはファイルに転送するためにバイト ストリームに変換するプロセスです。
>[シリアル化 - Google 検索](https://www.google.com/search?ei=ZeN6Xai8H-eFr7wPq8GE6AQ&q=%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%AB%E5%8C%96&oq=%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%AB%E5%8C%96&gs_l=psy-ab.3...0.0..113...0.0..0.0.0.......0......gws-wiz.f47xeWGzNEM&ved=0ahUKEwjogq-CxszkAhXnwosBHasgAU0Q4dUDCAs&uact=5)

## 17

### [JavaScriptのコールバックメソッドの基本的な使い方（forEach、map、some、filter、sort） \- Qiita](https://qiita.com/ryosuke0825/items/c5b515ff3e3f8e41160a)

forEachメソッド

配列の全ての要素を一回ずつ呼び出す。
呼び出した要素、その他のインデックス番号、元の配列を引数に設定できる。

インデックス番号と元の配列を使い要素を取り出せる

```js
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

arr.forEach((value, index, orgArray) => {
  console.log(`value : ${value} index : ${index} arr[${index}]: ${orgArray[index]}`);
});

// 結果
value : 1 index : 0 arr[0]: 1
value : 2 index : 1 arr[1]: 2
value : 3 index : 2 arr[2]: 3
value : 4 index : 3 arr[3]: 4
value : 5 index : 4 arr[4]: 5
value : 6 index : 5 arr[5]: 6
value : 7 index : 6 arr[6]: 7
value : 8 index : 7 arr[7]: 8
value : 9 index : 8 arr[8]: 9
value : 10 index : 9 arr[9]: 1
```

第三引数の元との配列の値を変更すると元の配列も変更される。

```js
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

console.log(arr)
arr.forEach((value, index, orgArray) => {
  orgArray[index] = value * 2;
});
console.log(arr)

// 結果

[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
[ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ]
```

mapメソッド

配列の全ての要素を1回ずつ呼び出して処理を実行し、その結果から新しい配列を生成する。
新しい配列に格納する要素を返す必要がある。

引数の指定方法はforEachと同じ

```js
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

let newArr = arr.map((value, index, orgArray) => {
  return value + 10;
});

// 省略した形
// let newArr = arr.map((value, index, orgArray) => value + 10);

console.log(newArr);

// 結果

[ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 ]
```

someメソッド

配列の全ての要素を1回ずつ呼び出して。関数内のテストを実行する。1つ以上がTrueなら、True、全てFalseならFalseを返す。

```js
let arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]

var tenOrMore = function(value) {
  return value >= 10;
};

console.log(arr1.some(tenOrMore));
console.log(arr2.some(tenOrMore));

console.log(arr1.some(value => value >= 10));
console.log(arr2.some(value => value >= 10));

// 結果

true
false
true
false
```

filterメソッド

配列の全ての要素を1回ずつ呼び出して、条件に当てはまる要素だけの配列を返す。

```js
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

const even = function(value) {
  return value % 2 === 0;
};

console.log(arr.filter(even));
console.log(arr.filter(value => value % 2 ===0));

// 結果

[ 2, 4, 6, 8, 10 ]
[ 2, 4, 6, 8, 10 ]
```

sortメソッド

配列の要素をソートした結果を返す。
デフォルトだと文字列として昇順にソートされる

```js
let arr1 = [1, 3, 7, 10, 2, 9, 4, 8, 5, 7]

// 文字列としてソート
console.log(arr1.sort());

// 数値としてソート
console.log(arr1.sort((x, y) => x - y));

let arr2 = [
  ['C001', 4],
  ['A002', 5],
  ['A001', 1],
  ['B001', 3],
  ['C002', 2],
  ['B002', 7]
]

// ソートキーを２種にする場合
arr2.sort((id, num) => {
  //ID（昇順）
  if (id[0] > num[0]) return 1;
  if (id[0] < num[0]) return -1;
  //番号（降順）
  if (id[0] > num[0]) return -1;
  if (id[0] < num[0]) return 1;
})

console.log(arr2);

// 結果

[ 1, 10, 2, 3, 4, 5, 7, 7, 8, 9 ]
[ 1, 2, 3, 4, 5, 7, 7, 8, 9, 10 ]
[ [ 'A001', 1 ],
  [ 'A002', 5 ],
  [ 'B001', 3 ],
  [ 'B002', 7 ],
  [ 'C001', 4 ],
  [ 'C002', 2 ] ]
```

forEach以外にも配列を扱える関数があるんだ

## 18

### [DBから取得したものをcsv化。ブラウザでダウンロードできるようにする。(Microsoft Excelでも見れるようにする\)。 - Qiita](https://qiita.com/69incat/items/09de31fb65f436460b42)

要件
- csvをダウンロードするAPIを作成
- ブラウザ上でボタンをクリックするとAPIが叩かれ、csvがダウンロードできるようにする。
- Microsoft Excelでも文字化けされないようにする

サーバーサイド(golang)

```go
package controller

import (
        "bytes"
        "encoding/csv"
        "strconv"

        "github.com/jinzhu/gorm"
        "github.com/seesaa/goa"
)

// 色々他のコントローラがあることを想定...
// ...

// GetCsv runs the get csv action.
func (c *MyAppController) GetCsv(ctx *app.GetCsvMyAppContext) error {
        // MyAppController_GetCsv: start_implement

        // ...DBから値を得るなどしていることを想定
        // ...

        b := &bytes.Buffer{}
        w := csv.NewWriter(b)
        headers := []string{"id", "名前", "猫種"}
        w.Write(headers)
        w.Flush()

        catDB := models.NewCatsDB(c.db)
        cats, _ := catDB.List(ctx.Context)
        for _, cat := range cats {
                record := []string{}
                record = append(record, strconv.Itoa(cat.ID))
                record = append(record, cat.Name)
                record = append(record, cat.Breed)

                w.Write(record)
                w.Flush()
        }

        rw := ctx.ResponseWriter
        rw.Header().Set("Content-Type", "text/csv")
        rw.Header().Set("Content-Disposition", "cat_list.csv")

        csvLength := strconv.Itoa(b.Len())
        rw.Header().Set("Content-Length", csvLength)

        rw.Write(b.Bytes())

        return ctx.NoContent()
        // MyAppController_GetCsv: end_implement
}
// 色々他のコントローラがあることを想定...
// ...
```
golangとは

>Goはプログラミング言語の1つである。2009年、GoogleでRobert Griesemer、ロブ・パイク、ケン・トンプソンによって設計された。Goは、静的型付け、C言語の伝統に則ったコンパイル言語、メモリ安全性（英語版）、ガベージコレクション、構造的型付け（英語版）、CSPスタイルの並行性などの特徴を持つ。
>[Go (プログラミング言語) - Wikipedia](https://ja.wikipedia.org/wiki/Go_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E))

フロントサイド(vue)

```js
<template lang="pug">
div
  // ...
  // ...
  button(@click="csvDownLoad()") CSVダウンロード

</template>
<script>
import saveAs from 'file-saver'

export default {
  ...
  ...
  methods: {
    csvDownLoad () {
      // axiosは、main.jsなどにグローバルで登録をしておき、this.$axiosで呼び出せるようにしてあります。
      this.$axios
        .get(`${process.env.API_URL}/api/cats/csv`) // getで呼び出すAPIは、今回はgoaで生成したものに合わせているという前提になります。
        .then(response => {
          let mimeType = response.headers['content-type']
          const name = response.headers['content-disposition']
          const data = response.data // サーバーサイド(goa)からのレスポンスに合わせている。
          const bom = new Uint8Array([0xEF, 0xBB, 0xBF]) // Microsoft Excelでも見れるように
、BOMを付与。
          const blob = new Blob([bom, data], {type: mimeType})
          saveAs(blob, name)
        })
    },
    ...
    ...
  }
}
</script>
```

axiosでサーバーサイドからのレスポンスしてから、BOM付与処理をする。

golangのResponseWriterを噛ませて、ブラウザ側でファイルを取得すると、サーバーサイド側でSjis化の処理していても、UTF-8フラグがつき、文字化けする。vue.js側でBOMを付与して、BOM付きのUTF-8にすることでMicrosoft Excelで文字化けせずに表示できる。

BOMってなんだよ

BOMとは

>バイト順記号(英: byte order mark; BOM) とは，Unicodeの符号化形式で符号化したテキストの先頭につける数バイトのデータのことである。このデータを元にUnicodeで符号化されていることおよび符号化の種類の判別に使用する。
>[バイト順記号 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%90%E3%82%A4%E3%83%88%E9%A0%86%E8%A8%98%E5%8F%B7)

## 19

### [【rails】google mapを表示させよう \- Qiita](https://qiita.com/hitochan/items/6cf89394d3afb06abdce)

APIを取得する

（https://console.developers.google.com/?hl=ja）から手順に沿ってAPIキーを取得しましょう

```js
<div id="map" style="width: 500px;height: 350px;"></div>

<script>
      var map;
      function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: -34.397, lng: 150.644},
          zoom: 8
        });
      }
</script>

<script src="https://maps.googleapis.com/maps/api/js?key=APIキー&callback=initMap"
    async defer></script>
```


`new google.maps.Map(document.getElementById('map')`でmapに要素を追加する。
`center: {lat: -34.397, lng: 150.644}`でマップの中心を設定する
`zoom: 8`マップの倍率を設定

倍率の基準
1: World
5: Landmass/continent
10: City
15: Streets
20: Buildings

`<script src="https://maps.googleapis.com/maps/api/js?key=APIキー&callback=initMap"
    async defer></script>`のAPIキーの部分に取得したAPIを取得する

これで表示でき、ピン留めや検索ができる

グーグルマップはこうやって表示するんだな

## 20

### [RSSをJSONに変換してくれるWebサービス「rss2json」の紹介 \- Qiita](https://qiita.com/920oj/items/9203c8ade378ec3b8eb7)

RSSとは

ニュースサイトやブログの新着記事更新情報を配信するための文書フォーマット

Rssをjsonにする方法

ress2json

https://rss2json.com/

「Enter the URL to your RSS feed」の欄に取得したいRSSのURLを入れ、「Convert to JSON」をクリックしたら下にjsonファイルが書きだされる。

また、ress2jsonのAPIを使うことで、jsonを直接取得できる。

例

RssのURLが`https://920oj.hatenablog.com/rss`の場合

ress2jsonのAPIを用いてjsonする場合、以下のURLになる

```
https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2F920oj.hatenablog.com%2Frss
```
URLはURLエンコードする必要がある

ただしこの場合はユーザー登録をしていないため、最大取得数は10件になるためそれ以上取得するには無料もユーザー登録をする必要がある。

詳しいプラン詳細

https://rss2json.com/plans

上記を使ってaxios通信

```html
<div id="main">
    <ul>
        <li v-for="items in hatenaArticles" :key="items.id"><a :href="items.link" target="_blank">{{items.title}}</a></li>
    </ul>
</div>
```

```js
export default {
  data() {
    return {
      hatenaArticles: null,
    }
  },
  mounted() {
    const self = this;
    this.$axios.get('https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2F920oj.hatenablog.com%2Frss')
      .then(function(response){
        self.hatenaArticles = response.data.items;
      })
      .catch(function(error){
        console.log(error);
      })
  }
}
```

こういうサービスがあるんだな

## 24

### [ユーザが「いいね！」をゲットした総数を表示させるのは、どうやるの？ \- Qiita](https://qiita.com/Hiroyuki-Hiroyuki/items/2b48a0ad24569b85aa22)

いいね！機能の実装方法はこちら

https://qiita.com/Hiroyuki-Hiroyuki/items/e5cb3b6595a7e476b73d

ユーザー(チャンネル)一覧表示

```php
@foreach ($users as $key => $user)

        @php

            $movies=$user->movies;

            $total=0;

            foreach ($movies as $key => $movie){
                $total += $movie->favorite_users()->count();
            }

        @endphp

        <div>{{ $user->name }}</div>

        //・・・（中略）・・・

@endforeach
```

各ユーザーの持っているコンテンツ(動画)を全て取り出す

```php
$movies=$user->movies;
```
foreach文を使いコンテンツ(movies)を1つ１つ抽出する

各コンテンツをいいね！しているユーザーを数える

```php
$total += $movie->favorite_users()->count();
```

`favorite_users()`関数はコンテンツ(Movie)のモデルで定義したもの

Movie.php

```php
class Movie extends Model
{

    //・・・中略・・・

    public function user()
    {
            return $this->belongsTo(User::class);
    }

    public function favorite_users()
    {
            return $this->belongsToMany(User::class,'favorites','movie_id','user_id')->withTimestamps();
    }

}
```

各movieのいいね！の数を数えたものを$totalに足し、下記のように表示させる

ユーザー(チャンネル)一覧表示

```php
@foreach ($users as $key => $user)

        @php

         //・・・（中略 上に同じ）・・・

        @endphp

        <div class="text-right">
           <span class="badge badge-pill badge-success">{{ $total }} いいね!</span>
        </div>

        <div>{{ $user->name }}</div>

        //・・・（中略）・・・

@endforeach
```

ツイッターでも似たようなことをやっているのかな?