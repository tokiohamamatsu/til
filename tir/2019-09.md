# 2019-09

## 02

### [Vue\.js \- コンポーネントとイベントハンドラの動的交換を、 v\-ifを使わず実装する \- Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

ifを使わずコンポーネントを動的に切り替え、コンポーネントごとにイベントハンドリングの方法を変更する

```html
<div id="app">
  <h2>switch component and event handler:</h2>
  <ul>
    <li>
      <input type="radio" name="mapping" value="hoge" @input="onSelect"> hoge
    </li>
    <li>
      <input type="radio" name="mapping" value="fuga" @input="onSelect"> fuga
    </li>
    <li>
      <input type="radio" name="mapping" value="piyo" @input="onSelect"> piyo
    </li>
  </ul>
  <component :is="current.component" @click="onClick"></component>
</div>
```

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
const fuga = {
  component: Vue.extend({
    template: '<button @click="onClick">fuga</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('fuga')
  }
}
const piyo = {
  component: Vue.extend({
    template: '<button @click="onClick">piyo</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('piyo')
  }
}

new Vue({
  el: "#app",
  data: {
    current: hoge,
  },
  computed: {
    viewModelMap: function () {
        return {
        hoge, fuga, piyo
      }
    }
  },
  methods: {
    onClick: function () {
      this.current.onClick()
    },
    onSelect: function (event) {
      const viewModelKey = event.target.value

      this.mapping(viewModelKey)
    },
    mapping: function (viewModelKey) {
      const viewModel = this.viewModelMap[viewModelKey]

      if (!viewModel) {
        return
      }

      this.current = this.viewModelMap[viewModelKey]    
    }
  }
})
```

- `:is`プロパティ
  componentタグと合わせて、動的にコンポーネントを切り替える機能。`is`に指定されたタグかVueコンポーネントが作画される。
  `is`にはコンポーネント名やオプションオブジェクトの他`VueConstructor`を渡してもいい

- コンポーネント イベントハンドリングの対応関係をオブジェクト化

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
```

効果

- 子コンポーネントがシンプルかつステートレスに保てる
- パターンが増えたら、子コンポーネント イベントハンドリングの対応オブジェクトを追加するだけ
- 子コンポーネントだけ/イベントハンドリングの方法だけ、という単位で交換可能、個々の実装は変更不要

>「イベントハンドリングの内容」として 
 A\. コンポーネント依存の処理 
 B\. コンポーネント非依存の処理 
  という分別が存在し得ることを、明示的に認識していなかったからと思われる。  Aについては、それはコンポーネント自身に関わることであるから、自身の内部にその内容が記述されるべきだと思う（オブジェクトの状態を変更する場合に、setterを定義せず、内部にその手続きを閉じ込めるのと同じ）（まあ普段は新しいオブジェクトを作っちゃうけど、ここでは「変更しないといけない」ということで）。 これが外部に引き剥がされてしまうのと、それはコンポーネントに関する知識がコンポーネントの外部に流出してしまうことになるので、好ましくない。
 一方、Bはそもそもコンポーネント非依存なのだから、コンポーネントからは独立した状態 = 別モジュールとして定義/実装されているはず。 元々コンポーネントからは引き剥がされているのだから、それの呼び出し方が外部化されたとしてもそれは一枚層が増えただけで、状況は変わっていない。
>[Vue.js - コンポーネントとイベントハンドラの動的交換を、 v-ifを使わず実装する - Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

オブジェクト化すれば後々楽になる

## 03

### [vee\-validate で「特定のフィールドに固有のバリデーションメッセージを設定する \- Qiita](https://qiita.com/ishiyama0530/items/106dfebe95165431f9e2)

特定のフィールドで、他の検証ルールに影響をあたえず、特定の検証ルールにのみバリデーションメッセージを設定する

lib/validatormessage

```js 
import { Validator } from 'vee-validate';

export function getError(
    validator: Validator,
    field: string,
    ruleMsssageMap: { [rule: string]: string }
): string | null {
    const errors = validator.errors.items.filter((e) => e.field === field);
    if (errors.length > 0) {
        const error = errors[0];
        let isExists = false;
        for (const rule in ruleMsssageMap) {
            if (error.rule === rule) {
                isExists = true;
            }
        }

        if (isExists) {
            return ruleMsssageMap[error.rule];
        } else {
            return validator.errors.first(field);
        }
    }

    return null;
}
```

```js
<template>
  <input
    type="text"
    name="myfield"
    v-model="myfieldValue"
    v-validate="{ required: true, regex: /[1-9]/ }"
  />
  <div v-show="myfieldError">
    {{ myfieldError  }}
  </div>
</template>
<script lang="ts">
import { getError } from '@lib/validatormessage'
...
computed: {
    myfieldError: {
      get: (): string | null => {
        return getError(this.$validator, 'myfield' { regex: 'cutome error message.' })
      },
    },
  },
<script>
```

myfieldErrorはバインドされており、変更された時、算出プロパティであるmyfieldErrorのget()が実行され、`lib/validatormessage`でエラー起きたruleと同じruleを探しメッセージを置き換える

## 04

### [Laravelでキャッシュクリアできず\.envを反映できない時の対応方法 \- Qiita](https://qiita.com/ponsuke0531/items/1a665c68d12a74a29a42)

`.env`でDBの設定を変更したが、キャッシュクリアがでできず、`.env`の設定が反映されない

storageディレクトリにあるキャッシュ用ディレクトリの中身を削除

```
# storageディレクトリにあるキャッシュのディレクトリを確認する
$ cat config/cache.php | grep storage_path | grep framework
            'path' => storage_path('framework/cache/data'),

# 中身を全削除する
$ rm storage/framework/cache/data/*

# 事象は何も変わらなかった
$ php artisan cache:clear

In  Oci8.phpline 464:

  ORA-01017: ユーザー名/パスワードが無効です。ログオンは拒否されました。
```

削除するキャッシュのファイルが違うため事象は変わらなかった

>\.env ファイルの読み込みは， php artisan config:cache していない場合にしか行われません！ キャッシュを有効にしてある場合， \.env に書いてあるだけでシェルから起動する時点で定義されていない環境変数はすべて未定義になってしまうので注意しましょう。
>[[Laravel] Laravel では env() を config 系ファイル以外の場所に書いてはいけない - mpyw's tech blog](https://mpyw.qrunch.io/entries/nyuqLPQzA2ej0Bo1)

>設定ファイルのキャッシュを止めることはできません。あなたがする必要がある唯一のことはconfig：cacheを呼ばないことです。 ファイル自体はbootstrap / cache / config\.phpにあります。
>[laravel-5 – Laravel 5が設定をキャッシュしないようにする方法 - コードログ](https://codeday.me/jp/qa/20190119/154959.html)

対処法 bootstrap/cache/config.phpを削除する

```
# config.phpを削除する
$ rm bootstrap/cache/config.php
# うまく行った!
$ php artisan config:clear
Configuration cache cleared!
```

DBの設定には気をつけよう

## 05

### [Laravel 6\.0 アップデートメモ \- Qiita](https://qiita.com/a_yasui/items/12d3b2d6ac2f29d364c9)

Laravel6 が2019/09/04にリリースされた。このバージョンからバージョン番号にsemverが採用され、しれっと新しい機能が追加されても追いかけられるようなった

追加点と変更点
- Authorized Resources & viewAny
  Controller Helperにて、Policy Method `viewAny`が追加され、それに対応したController Method側には`index`が追加された。すでに`index`メソッドがある場合呼ばれなくなる
- Laravel Helperにあった関数`str_`や`array_`が新しいlaravel/helpers パッケージに移った。今まで通りに使うには`composer require laravel/helpers`を実行する
- Facade/Ignition
  開発環境時のエラーメッセージに`lgnition`が採用された
- Improved Authorization Responses
  認証時メッセージを簡単に変更できるようになった
- Job Middleware
  JobにMiddlewareを被せれるようになった
- Laravel UI
Laravelのjsまわりが分離され,laravel/uiになった
- PHP 7.2 Required
  php7.1以下は非推奨になり、2019/12/1にサポートが切れる
- Authentication RegisterController
  RegisterControllerに変更があり、`RegisterController`の小クラスで`registerd`や`regidter`メソッドをしている時、親クラスの`registered`メソッドでユーザーの追加やイベントの発火などをしているため、`parent::registered()`や`parent::register` を呼び出さないとユーザーの新規登録に失敗する。
- Carbon 1.x No Longer Supported
  Cardon 1.x が打ち切られるので、Cardon2にアップグレードする
- Eloquent Arrayable & toArray
  Eloquentの`toAttay`メソッドの返り値が`Illuminate\Contracts\Support\Arrayable `を実装する属性を普通の配列(array)にキャストするようになる
- Eloquent BelongsTo::update Method
  `$model->user()->update([]);`の場合eventが発生するが、`$model->user->update([]);`の場合でとeventが発生しない
- Eloquent Primary Key Types
  Primary Keyはint/bigintだけだったが、stringにも対応できるようになる
- Localization Lang::getFromJson Method
  Lang::getとLang::getFromJsonが統合された。Lang::getFromJsonを呼んでいる部分は、Lang::getを呼び出すように変更する
- Queue Retry Limit
  php artisan queue:workにおいてlaravel６では1回失敗したらすぐにfailedに変更される
- Resend Email Verification Route
  標準の再メール認証がGet Requestから、Post Request + csrf 付きに変更された
- The Input Facade
  Input Facade は Request Facadeと機能が同じなので削除された。`Input::get()`は`Request::input()`に置換する

 Eloquentの変更点が多い

 ## 06

 ### [Laravel ミドルウェアの設定について \- Qiita](https://qiita.com/KZ-taran/items/a746a96b12489ae56553)

 Middlewareクラスの生成

 Middlewareクラスは`$ php artisan make:middleware {クラス名}`コマンドを実行し、`app/Http/Middleware/`にファイルを生成する。
 生成されたMiddlewareクラス内にある`handle()`に実装内容を書く
 - `$response = $next($request);`に前に実装内容を記載するか、後に記載するかでBefor MiddlewareかAfter Middlewareかを書き分けれる

Middlewareの登録

実装が完了したMiddlewareを実際に通すようにKarnel.phpに追記する

```php
<?php

namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel
{
    protected $middleware = [
        \App\Http\Middleware\TrustProxies::class,
        \App\Http\Middleware\CheckForMaintenanceMode::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        ...
    ];
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            ...
        ],

        'api' => [
            'throttle:60,1',
            'auth:api',
            ...
        ],
    ];
    protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        ...
    ];
    protected $middlewarePriority = [
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\Authenticate::class,
        ...
    ];
```

- $middleware(グローバルミドルウェア)
  アプリケーションの全HTTPリクエストで実行したいMiddlewareを書く
- $middlewareGroups(ミドルウェアグループ)
  複数のMiddlewareをまとめて登録し、短縮キーを指定する
- $routeMiddleware(ルートミドルウェア)
  Middlewareを個々に登録し、短縮キーを指定する
- $middlewarePriority
  特定の順番でMiddlewareの実行をする必要がある場合に記載順でMiddlewareを優先で実行させる。※$middleware(グローバルミドルウェア)ではないものを記載する。

Routeに対してMiddlwareを割り当てる

$middlewareGroups

webがキーの場合

```php
// 1つのルートに対してミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('web');

// 複数のルートに対してミドルウェアを指定する場合
Route::group(['middleware' => ['web']], function () {
    //
});
```

$routemiddleware

authMiddlewareを割り当てる場合

```php
// 一つのルートに対してミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('auth');

// １つのルートに対して複数のミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('auth', 'auth2');

// 複数のルートに対して１つのミドルウェアを指定する場合
Route::group(['middleware' => 'auth'], function () {
    //
});

// 複数のルートに対して複数のミドルウェアを指定する場合
Route::group(['middleware' => ['auth', 'auth2'], function () {
    //
});
```

繰り返し覚える

## 09

### [超カンタン！CSSで画像を自在に切り抜く方法 \- Qiita](https://qiita.com/Hiroyuki-Hiroyuki/items/8a3875fde5561d96f2eb)

画像アップロード

```html
<h2>トップ画像をアップ</h2>

<figure>

  <img class="rounded" src="{{ Storage::disk('s3')->url(Auth::user()->top_image_url) }}">
    <figcaption>現在のチャンネルトップ画像（編集前）</figcaption>

</figure>

<form method="POST" action="/storeTop" enctype="multipart/form-data">

  {{ csrf_field() }}

  <input type="file" name="photo" class="btn">

　<input type="submit" value="更新する？" class="button btn btn-primary">
             　
  </form>
```

画像を切り抜く

```html
<h2>トップ画像を編集</h2>

  <figure>

    <img class="rounded" src="{{ Storage::disk('s3')->url(Auth::user()->top_image_url) }}" style="width:1200px; height:200px; object-fit:cover; object-position:0% {{ $user->top_trim }}%;">
    <figcaption>現在のチャンネルトップ画像（編集済）</figcaption>

  </figure>
　　　　　　　　　　
　<form method="POST" action="/topTrim">

    <div class="form-group">
      <label>切り取る位置（高さ）を 0 ~ 100 の数値で入力</label>
        <div>
          <input type="number" name="top_trim" required>
          <div>例）画像の一番上を切り取る : 0 を入力</div>
          <div>　　画像の一番下を切り取る : 100 を入力</div>
        </div>
    </div>

    <input type="submit" value="更新する？" class="btn btn-primary">

  </form>
```

imgタグのsrc=""にアップした画像と同じパスを指定する

横に細長く切り抜きたい時,imgタグに
`style="width:1200px; height:200px; object-fit:cover; object-position:0% {{ $user->top_trim }}%;`と記載する。

width:1200px;height:200pxと、任意で表示させたい画像幅と高さが書いてある

`objekct-fit:cover`と記載することで、画像の縦横比を保持したまま。トリミングが可能となる。

`object-position:横の位置% 縦の位置%;`と追記擦れば、

- 横の位置=1番左から〇%の位置を切り取る
- 縦の位置=1番上から〇%の位置を切り取る

とすることができる。

`object-position:0% {{ $user->top_trim }}%;`

とすれば、%の前の数値を変数として、任意の値を持ってこれる

#### 参考

[1行追加でOK！CSSだけで画像をトリミングできる「object\-fit」プロパティー ](https://www.webcreatorbox.com/tech/object-fit)

cssの設定方法はこんな方法もあるんだ