# 2019-09

## 02

### [Vue\.js \- コンポーネントとイベントハンドラの動的交換を、 v\-ifを使わず実装する \- Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

ifを使わずコンポーネントを動的に切り替え、コンポーネントごとにイベントハンドリングの方法を変更する

```html
<div id="app">
  <h2>switch component and event handler:</h2>
  <ul>
    <li>
      <input type="radio" name="mapping" value="hoge" @input="onSelect"> hoge
    </li>
    <li>
      <input type="radio" name="mapping" value="fuga" @input="onSelect"> fuga
    </li>
    <li>
      <input type="radio" name="mapping" value="piyo" @input="onSelect"> piyo
    </li>
  </ul>
  <component :is="current.component" @click="onClick"></component>
</div>
```

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
const fuga = {
  component: Vue.extend({
    template: '<button @click="onClick">fuga</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('fuga')
  }
}
const piyo = {
  component: Vue.extend({
    template: '<button @click="onClick">piyo</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('piyo')
  }
}

new Vue({
  el: "#app",
  data: {
    current: hoge,
  },
  computed: {
    viewModelMap: function () {
        return {
        hoge, fuga, piyo
      }
    }
  },
  methods: {
    onClick: function () {
      this.current.onClick()
    },
    onSelect: function (event) {
      const viewModelKey = event.target.value

      this.mapping(viewModelKey)
    },
    mapping: function (viewModelKey) {
      const viewModel = this.viewModelMap[viewModelKey]

      if (!viewModel) {
        return
      }

      this.current = this.viewModelMap[viewModelKey]    
    }
  }
})
```

- `:is`プロパティ
  componentタグと合わせて、動的にコンポーネントを切り替える機能。`is`に指定されたタグかVueコンポーネントが作画される。
  `is`にはコンポーネント名やオプションオブジェクトの他`VueConstructor`を渡してもいい

- コンポーネント イベントハンドリングの対応関係をオブジェクト化

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
```

効果

- 子コンポーネントがシンプルかつステートレスに保てる
- パターンが増えたら、子コンポーネント イベントハンドリングの対応オブジェクトを追加するだけ
- 子コンポーネントだけ/イベントハンドリングの方法だけ、という単位で交換可能、個々の実装は変更不要

>「イベントハンドリングの内容」として 
 A\. コンポーネント依存の処理 
 B\. コンポーネント非依存の処理 
  という分別が存在し得ることを、明示的に認識していなかったからと思われる。  Aについては、それはコンポーネント自身に関わることであるから、自身の内部にその内容が記述されるべきだと思う（オブジェクトの状態を変更する場合に、setterを定義せず、内部にその手続きを閉じ込めるのと同じ）（まあ普段は新しいオブジェクトを作っちゃうけど、ここでは「変更しないといけない」ということで）。 これが外部に引き剥がされてしまうのと、それはコンポーネントに関する知識がコンポーネントの外部に流出してしまうことになるので、好ましくない。
 一方、Bはそもそもコンポーネント非依存なのだから、コンポーネントからは独立した状態 = 別モジュールとして定義/実装されているはず。 元々コンポーネントからは引き剥がされているのだから、それの呼び出し方が外部化されたとしてもそれは一枚層が増えただけで、状況は変わっていない。
>[Vue.js - コンポーネントとイベントハンドラの動的交換を、 v-ifを使わず実装する - Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

オブジェクト化すれば後々楽になる

## 03

### [vee\-validate で「特定のフィールドに固有のバリデーションメッセージを設定する \- Qiita](https://qiita.com/ishiyama0530/items/106dfebe95165431f9e2)

特定のフィールドで、他の検証ルールに影響をあたえず、特定の検証ルールにのみバリデーションメッセージを設定する

lib/validatormessage

```js 
import { Validator } from 'vee-validate';

export function getError(
    validator: Validator,
    field: string,
    ruleMsssageMap: { [rule: string]: string }
): string | null {
    const errors = validator.errors.items.filter((e) => e.field === field);
    if (errors.length > 0) {
        const error = errors[0];
        let isExists = false;
        for (const rule in ruleMsssageMap) {
            if (error.rule === rule) {
                isExists = true;
            }
        }

        if (isExists) {
            return ruleMsssageMap[error.rule];
        } else {
            return validator.errors.first(field);
        }
    }

    return null;
}
```

```js
<template>
  <input
    type="text"
    name="myfield"
    v-model="myfieldValue"
    v-validate="{ required: true, regex: /[1-9]/ }"
  />
  <div v-show="myfieldError">
    {{ myfieldError  }}
  </div>
</template>
<script lang="ts">
import { getError } from '@lib/validatormessage'
...
computed: {
    myfieldError: {
      get: (): string | null => {
        return getError(this.$validator, 'myfield' { regex: 'cutome error message.' })
      },
    },
  },
<script>
```

myfieldErrorはバインドされており、変更された時、算出プロパティであるmyfieldErrorのget()が実行され、`lib/validatormessage`でエラー起きたruleと同じruleを探しメッセージを置き換える

## 04

### [Laravelでキャッシュクリアできず\.envを反映できない時の対応方法 \- Qiita](https://qiita.com/ponsuke0531/items/1a665c68d12a74a29a42)

`.env`でDBの設定を変更したが、キャッシュクリアがでできず、`.env`の設定が反映されない

storageディレクトリにあるキャッシュ用ディレクトリの中身を削除

```
# storageディレクトリにあるキャッシュのディレクトリを確認する
$ cat config/cache.php | grep storage_path | grep framework
            'path' => storage_path('framework/cache/data'),

# 中身を全削除する
$ rm storage/framework/cache/data/*

# 事象は何も変わらなかった
$ php artisan cache:clear

In  Oci8.phpline 464:

  ORA-01017: ユーザー名/パスワードが無効です。ログオンは拒否されました。
```

削除するキャッシュのファイルが違うため事象は変わらなかった

>\.env ファイルの読み込みは， php artisan config:cache していない場合にしか行われません！ キャッシュを有効にしてある場合， \.env に書いてあるだけでシェルから起動する時点で定義されていない環境変数はすべて未定義になってしまうので注意しましょう。
>[[Laravel] Laravel では env() を config 系ファイル以外の場所に書いてはいけない - mpyw's tech blog](https://mpyw.qrunch.io/entries/nyuqLPQzA2ej0Bo1)

>設定ファイルのキャッシュを止めることはできません。あなたがする必要がある唯一のことはconfig：cacheを呼ばないことです。 ファイル自体はbootstrap / cache / config\.phpにあります。
>[laravel-5 – Laravel 5が設定をキャッシュしないようにする方法 - コードログ](https://codeday.me/jp/qa/20190119/154959.html)

対処法 bootstrap/cache/config.phpを削除する

```
# config.phpを削除する
$ rm bootstrap/cache/config.php
# うまく行った!
$ php artisan config:clear
Configuration cache cleared!
```

DBの設定には気をつけよう

## 05

### [Laravel 6\.0 アップデートメモ \- Qiita](https://qiita.com/a_yasui/items/12d3b2d6ac2f29d364c9)

Laravel6 が2019/09/04にリリースされた。このバージョンからバージョン番号にsemverが採用され、しれっと新しい機能が追加されても追いかけられるようなった

追加点と変更点
- Authorized Resources & viewAny
  Controller Helperにて、Policy Method `viewAny`が追加され、それに対応したController Method側には`index`が追加された。すでに`index`メソッドがある場合呼ばれなくなる
- Laravel Helperにあった関数`str_`や`array_`が新しいlaravel/helpers パッケージに移った。今まで通りに使うには`composer require laravel/helpers`を実行する
- Facade/Ignition
  開発環境時のエラーメッセージに`lgnition`が採用された
- Improved Authorization Responses
  認証時メッセージを簡単に変更できるようになった
- Job Middleware
  JobにMiddlewareを被せれるようになった
- Laravel UI
Laravelのjsまわりが分離され,laravel/uiになった
- PHP 7.2 Required
  php7.1以下は非推奨になり、2019/12/1にサポートが切れる
- Authentication RegisterController
  RegisterControllerに変更があり、`RegisterController`の小クラスで`registerd`や`regidter`メソッドをしている時、親クラスの`registered`メソッドでユーザーの追加やイベントの発火などをしているため、`parent::registered()`や`parent::register` を呼び出さないとユーザーの新規登録に失敗する。
- Carbon 1.x No Longer Supported
  Cardon 1.x が打ち切られるので、Cardon2にアップグレードする
- Eloquent Arrayable & toArray
  Eloquentの`toAttay`メソッドの返り値が`Illuminate\Contracts\Support\Arrayable `を実装する属性を普通の配列(array)にキャストするようになる
- Eloquent BelongsTo::update Method
  `$model->user()->update([]);`の場合eventが発生するが、`$model->user->update([]);`の場合でとeventが発生しない
- Eloquent Primary Key Types
  Primary Keyはint/bigintだけだったが、stringにも対応できるようになる
- Localization Lang::getFromJson Method
  Lang::getとLang::getFromJsonが統合された。Lang::getFromJsonを呼んでいる部分は、Lang::getを呼び出すように変更する
- Queue Retry Limit
  php artisan queue:workにおいてlaravel６では1回失敗したらすぐにfailedに変更される
- Resend Email Verification Route
  標準の再メール認証がGet Requestから、Post Request + csrf 付きに変更された
- The Input Facade
  Input Facade は Request Facadeと機能が同じなので削除された。`Input::get()`は`Request::input()`に置換する

 Eloquentの変更点が多い

 ## 06

 ### [Laravel ミドルウェアの設定について \- Qiita](https://qiita.com/KZ-taran/items/a746a96b12489ae56553)

 Middlewareクラスの生成

 Middlewareクラスは`$ php artisan make:middleware {クラス名}`コマンドを実行し、`app/Http/Middleware/`にファイルを生成する。
 生成されたMiddlewareクラス内にある`handle()`に実装内容を書く
 - `$response = $next($request);`に前に実装内容を記載するか、後に記載するかでBefor MiddlewareかAfter Middlewareかを書き分けれる

Middlewareの登録

実装が完了したMiddlewareを実際に通すようにKarnel.phpに追記する

```php
<?php

namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel
{
    protected $middleware = [
        \App\Http\Middleware\TrustProxies::class,
        \App\Http\Middleware\CheckForMaintenanceMode::class,
        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
        ...
    ];
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            ...
        ],

        'api' => [
            'throttle:60,1',
            'auth:api',
            ...
        ],
    ];
    protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        ...
    ];
    protected $middlewarePriority = [
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\Authenticate::class,
        ...
    ];
```

- $middleware(グローバルミドルウェア)
  アプリケーションの全HTTPリクエストで実行したいMiddlewareを書く
- $middlewareGroups(ミドルウェアグループ)
  複数のMiddlewareをまとめて登録し、短縮キーを指定する
- $routeMiddleware(ルートミドルウェア)
  Middlewareを個々に登録し、短縮キーを指定する
- $middlewarePriority
  特定の順番でMiddlewareの実行をする必要がある場合に記載順でMiddlewareを優先で実行させる。※$middleware(グローバルミドルウェア)ではないものを記載する。

Routeに対してMiddlwareを割り当てる

$middlewareGroups

webがキーの場合

```php
// 1つのルートに対してミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('web');

// 複数のルートに対してミドルウェアを指定する場合
Route::group(['middleware' => ['web']], function () {
    //
});
```

$routemiddleware

authMiddlewareを割り当てる場合

```php
// 一つのルートに対してミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('auth');

// １つのルートに対して複数のミドルウェアを指定する場合
Route::get('/', function () {
    //
})->middleware('auth', 'auth2');

// 複数のルートに対して１つのミドルウェアを指定する場合
Route::group(['middleware' => 'auth'], function () {
    //
});

// 複数のルートに対して複数のミドルウェアを指定する場合
Route::group(['middleware' => ['auth', 'auth2'], function () {
    //
});
```

繰り返し覚える

## 09

### [超カンタン！CSSで画像を自在に切り抜く方法 \- Qiita](https://qiita.com/Hiroyuki-Hiroyuki/items/8a3875fde5561d96f2eb)

画像アップロード

```html
<h2>トップ画像をアップ</h2>

<figure>

  <img class="rounded" src="{{ Storage::disk('s3')->url(Auth::user()->top_image_url) }}">
    <figcaption>現在のチャンネルトップ画像（編集前）</figcaption>

</figure>

<form method="POST" action="/storeTop" enctype="multipart/form-data">

  {{ csrf_field() }}

  <input type="file" name="photo" class="btn">

　<input type="submit" value="更新する？" class="button btn btn-primary">
             　
  </form>
```

画像を切り抜く

```html
<h2>トップ画像を編集</h2>

  <figure>

    <img class="rounded" src="{{ Storage::disk('s3')->url(Auth::user()->top_image_url) }}" style="width:1200px; height:200px; object-fit:cover; object-position:0% {{ $user->top_trim }}%;">
    <figcaption>現在のチャンネルトップ画像（編集済）</figcaption>

  </figure>
　　　　　　　　　　
　<form method="POST" action="/topTrim">

    <div class="form-group">
      <label>切り取る位置（高さ）を 0 ~ 100 の数値で入力</label>
        <div>
          <input type="number" name="top_trim" required>
          <div>例）画像の一番上を切り取る : 0 を入力</div>
          <div>　　画像の一番下を切り取る : 100 を入力</div>
        </div>
    </div>

    <input type="submit" value="更新する？" class="btn btn-primary">

  </form>
```

imgタグのsrc=""にアップした画像と同じパスを指定する

横に細長く切り抜きたい時,imgタグに
`style="width:1200px; height:200px; object-fit:cover; object-position:0% {{ $user->top_trim }}%;`と記載する。

width:1200px;height:200pxと、任意で表示させたい画像幅と高さが書いてある

`objekct-fit:cover`と記載することで、画像の縦横比を保持したまま。トリミングが可能となる。

`object-position:横の位置% 縦の位置%;`と追記擦れば、

- 横の位置=1番左から〇%の位置を切り取る
- 縦の位置=1番上から〇%の位置を切り取る

とすることができる。

`object-position:0% {{ $user->top_trim }}%;`

とすれば、%の前の数値を変数として、任意の値を持ってこれる

#### 参考

[1行追加でOK！CSSだけで画像をトリミングできる「object\-fit」プロパティー ](https://www.webcreatorbox.com/tech/object-fit)

cssの設定方法はこんな方法もあるんだ

## 10

### [Laravel Nuxt StripeでCheckout決済機能を実装する \- Qiita](https://qiita.com/gemetasu1103/items/c7f84d429eef8477c3dc)

Stripeのアカウント作成

こちらでアカウント作成
[Stripe: Login](https://dashboard.stripe.com/login?redirect=%2F)

StipeAPIライブラリをインストール

`composer require stripe/stripe-php`

API側の実装

vue側でクレジットカード情報を入力し、クレジット情報が正しい場合tokenが発行され、そのtokenを使用してAPI側で決済処理をする・

```php
public function pay(Request $request)
    {
        // Set your secret key: remember to change this to your live secret key in production
        // See your keys here: https://dashboard.stripe.com/account/apikeys
        Stripe::setApiKey('sk_test_XXXXXXXXXXXXXXXXXXXXXXXX');

        try {
            // Token is created using Checkout or Elements!
            // Get the payment token ID submitted by the form:
            $token = $request->input('stripeToken');
            $charge = Charge::create([
                'amount' => $request->input('amount'),
                'currency' => 'jpy',
                'description' => 'Example charge',
                'source' => $token,
            ]);
        }catch (Stripe\Error\Card $e){
            // 決済に失敗したらエラーメッセージを返す
            return response()->json([
                'success' => false,
                'errors' => $e->getMessage()
            ], 422);
        }

        $user_wallet = $this->exchange->cashExchange($request);

        return response()->json([
            'success' => true,
            'data' => $user_wallet,
            'message' => '現金からポイントに換金が完了しました'
        ], 200);

    }
```

フロント側の実装

vue-stripe-checkoutをインストール

`npm install vue-stripe-checkout@1.2.6 --save`

プラグインの作成

```js
import Vue from 'vue'
import VueStripeCheckout from 'vue-stripe-checkout'

Vue.use(VueStripeCheckout, process.env.STRIPE_PUBLIC_KEY)
```

Vueのテンプレート

クレジット決済したい画面で`<vue-strope-checkout>`

```js
<template>
  <div class="container">
    <h2 class="title is-4">クレジットで換金</h2>
    <!-- 入金額 -->
    <div class="field">
      <p class="control has-icons-left has-icons-right">
        <input
          v-model.number="amount"
          class="input is-medium"
          :class="{ 'is-danger': errors.amount }"
          type="number"
          placeholder="入金額"
        />
        <span class="icon is-small is-left">
          <i class="fas fa-yen-sign"></i>
        </span>
      </p>
      <div class="help is-danger">
        <ul v-if="errors.amount">
          <li v-for="msg in errors.amount" :key="msg">
            {{ msg }}
          </li>
        </ul>
      </div>
    </div>
    <div class="field">
      <b-field label="">
        <p>{{ current_time }} 現在</p>
      </b-field>
    </div>
    <div class="field">
      <b-field label="換金レート">
        <p>
          1000円 ⇔
          {{
            Math.floor(
              1000 *
                currency_date.credit_payment *
                currency_date.cash_rate *
                currency_date.cash_exchange
            )
          }}ポイント
        </p>
      </b-field>
    </div>
    <div class="field">
      <b-field label="購入ポイント">
        <p>
          {{
            Math.floor(
              amount *
                currency_date.credit_payment *
                currency_date.cash_rate *
                currency_date.cash_exchange
            )
          }}ポイントへ変換
        </p>
      </b-field>
    </div>

    <vue-stripe-checkout
      ref="checkoutRef"
      :name="name"
      :description="description"
      :currency="currency"
      :amount="amount"
      :locale="locale"
      :panel-label="label"
      :allow-remember-me="true"
      @done="done"
      @opened="opened"
      @closed="closed"
      @canceled="canceled"
    ></vue-stripe-checkout>

    <div class="field-button">
      <input
        class="button is-blue is-large is-fullwidth"
        value="OK"
        @click="stripeCheckout"
      />
    </div>
  </div>
</template>
```

スクリプト側

`vue-stripe-checkout`側でクレジット情報を入力し、成功したら`token`が発行されるので、API側にリクエストを投げる

```js
data() {
    return {
      name: 'Guild',
      description: 'カード情報を入力してください。',
      currency: 'JPY',
      label: 'カード支払い',
      locale: 'ja',
      amount: 0,
      current_time: this.$moment().format('YYYY/MM/DD HH:mm:ss'),
      currency_date: {},
      form: {
        user_id: '',
        currency_id: '',
        payment: 0,
        stripeToken: ''
      }
    }
  },
  async asyncData({ app, store }) {
    const { data } = await app.$axios.get(
      `/api/user/currency/${store.getters['event_info/currency']}`
    )
    return { currency_date: data.data[0] }
  },
  methods: {
    async stripeCheckout() {
      // this.$checkout.close()
      // is also available.
      // token - is the token object
      // args - is an object containing the billing and shipping address if enabled
      await this.$refs.checkoutRef.open()
    },
    async done({ token, args }) {
      // token - is the token object
      // args - is an object containing the billing and shipping address if enabled
      // do stuff...

      this.form.user_id = this.$nuxt.$auth.user.id
      this.form.currency_id = this.currencyId
      this.form.payment = this.amount
      this.form.stripeToken = token.id

      await this.$axios
        .$post('/api/user/wallet/pay', this.form)
        .then(data => {
          this.$router.push('/client/payment/thanks')
        })
        .catch(errors => {
          alert(JSON.stringify(errors))
        })
    },
    opened() {
      // do stuff
    },
    closed() {
      // do stuff
    },
    canceled() {
      // do stuff
    }
  }
```

Stripeとは

>ストライプ（英語: Stripe）とは個人や企業がインターネットを通して料金を受納する方法を提供する企業である。
>[ストライプ (企業) - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%97_(%E4%BC%81%E6%A5%AD))

Stripeというものがあるんだ

## 11

### [Vuexについてまとめ、使ってみる。 \- Qiita](https://qiita.com/hirooka0527/items/660b697d64975439f5fa)

Vuexとは

VuexはVue.jsのため作成された状態管理ライブラリ


Vuexのアーキテクチャ


StateとStore

StateはVuexでコンポーネント間でグローバルな状態を持つ単一のステートツリー、StareはStoreで管理される。
Stateはアプリケーション内で1つだけ作成され、そのため。アプリケーションが信頼できる唯一の情報源として機能する。

Mutations

VuexのStateを変更する唯一の方法はMutationsをコミットすること

```js
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 状態を変更する
      state.count++
    }
  }
})
```

Mutationsはイベントに近い概念を持ち、タイプとハンドラを持つ
上記のコードの場合`increment`がタイプ、メソッド部分を含めるとハンドラになる。
Mutationは直接呼び出すことができず下記のようにミューテーションタイプを指定しコミットすること

```js
store.commit('increment')
```

また、Mutationsは非同期な処理を書くことはできない

Action

アクションはMutationをコミットし、非同期な処理を書くことができる。

```js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
  }
})
```

アクションでは、`context`オブジェクトを受け取る。`context.commit`でMutationをコミットでき`content.getter`でgetterにアクセスできる。
アクションそのものは、`store.dispatch`がトリガーとして実行する

```js
store.dispatch('increment')
```

`context.commit`を呼び出さないのはAction内で非同期な処理が記述できるから

```js
actions: {
  incrementAsync ({ commit }) {
    setTimeout(() => {
      commit('increment')
    }, 1000)
  }
}
```

Getter

Stateの状態からフィルタリングとして値を取り出すときGetterを使う

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})
```

Getterは以下のように呼び出せる

```js
store.getters.doneTodos
```

Vuexについてはこちら

https://vuex.vuejs.org/ja/


Vuexは便利そうだな

## 12

### [【jQuery => async/await】再帰で可変長の非同期処理の要求を順番に実行する \- Qiita](https://qiita.com/ant_inous/items/09c040938fd7a4a3eda8)

Promise

非同期処理を作成する胴元的存在 async/awaitを使い元をたどればこれに行き着く

```js
var sample = new Promise(function(resolve) { 
    resolve('true!');
 });
```

async

`async function(){}`という形で定義し、定義すると非同期関数となりPromiseを返す。jQueryでいうところの$.ajax()と同じように.then()で繋げられる

async関数の返り値

- return
  返り値のPromiseはresolveになる
  
- throwや例外
  返り値のPromiseはrejectになる

await

async関数の進みは、これをつけた処理の部分でいったんPromiseの結果が返されるまで待つ、だから中でPromiseを使う

JQueryのコード

```js
//jQuery $.Deferred()
var asyncTest=function(value){
    var def=$.Deferred();
    setTimeout(() => {
        def.resolve(value * 5);
    }, value * 200);
    return def.promise();
};

var order=[1,3,5,7,9];//テスト用の処理要求

var TestFunc=function(def){
    var req=order.shift();
    $.when(asyncTest(req))
        .then(
        function(data){
            console.log(data);
            if(order.length){
                TestFunc(def);
            }
            else{
                def.resolve('complete!!');
            }
        },
        function(jqXHR,textStatus,errorThrown){
            alert(textStatus+"_"+errorThrown);
            def.reject();
        }
    );
    return def.promise();
};
var def=$.Deferred();
TestFunc(def)
    .then((data) => {
    console.log(data);
});
```

async/awaitのコード

```js
//JavaScript async/await
const _asyncTest=(value) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(value * 5);
        }, value * 200);
    });
};

const _order=[1,3,5,7,9];//テスト用の処理要求

const _TestFunc = async () => {
    var req=_order.shift();
    var data = await _asyncTest(req);
    console.log(data);
    if(_order.length){
        return await _TestFunc();
    }
    else{
        return 'complete!';
    }
};

_TestFunc()
    .then((data) => {
    console.log(data);
});
```

比較すると,多少はasync,awaitの方が記述量が少ない

aysnc/awaitはBabelしないといけないのか

Babelとは

>「次世代JavaScript記法のためのコンパイラ」です。コンパイラじゃなくてトランスパイラという表現を使う人もいます。  Babelは「黒い画面」で動くツールで、これを使うと新しい文法で記述したJSファイルを変換して、古い文法で構成されたものを生成することができます。そしてそれは古い環境でも動作します。Sass/SCSS→CSSみたいな。
>[Babelを使って現代的JavaScriptを始める。（現代的JavaScriptおれおれアドベントカレンダー2017 – 01日目） | Ginpen.com](https://ginpen.com/2017/12/01/babel/)


## 13

### [PHPのunserializeでクラスプロパティに変更があった場合 \- Qiita](https://qiita.com/nishimura/items/b3996b56c1cb181c766e)

セッションにオブジェクトを保存し、クラスに変更があった場合どうなるか

unserializeとは

>unserialize\(\) は、シリアル化された変数を PHP 変数値に戻す変換を行います。
>[PHP: unserialize - Manual](https://www.php.net/manual/ja/function.unserialize.php)

foo.php
```php 
<?php
class Foo
{
    private $id;
    protected $name;
    public $attributes = [];

    public function __construct(int $id, string $name, array $attrs)
    {
        $this->id = $id;
        $this->name = $name;
        $this->attributes = $attrs;
    }
}
```

serialize.php
```php
<?php
class Foo
{
    private $id;
    protected $name;
    public $attributes = [];

    public function __construct(int $id, string $name, array $attrs)
    {
        $this->id = $id;
        $this->name = $name;
        $this->attributes = $attrs;
    }
}
```

useerialize.php
```php
<?php
error_reporting(-1);
require_once 'Foo.php';
$data = stream_get_contents(STDIN);
var_dump(unserialize($data));
```

serialize=>unserializeを実行する

```php
$ php serialize.php | php unserialize.php
/tmp/php/unserialize.php:5:
class Foo#1 (3) {
  private $id =>
  int(3)
  protected $name =>
  string(3) "foo"
  public $attributes =>
  array(2) {
    'bar' =>
    string(3) "baz"
    [0] =>
    int(7)
  }
}
```

プロパティが増えた場合

Foo1.php
```php
<?php
class Foo
{
    private $id;
    protected $name;
    public $attributes = [];
    public $opt;
    public function __construct(int $id, string $name, array $attrs, ?string $opt)
    {
        $this->id = $id;
        $this->name = $name;
        $this->attributes = $attrs;
        $this->opt = $opt;
    }
}
```

```php
$ php serialize.php | php unserialize1.php
/tmp/php/unserialize1.php:8:
class Foo#1 (4) {
  private $id =>
  int(3)
  protected $name =>
  string(3) "foo"
  public $attributes =>
  array(2) {
    'bar' =>
    string(3) "baz"
    [0] =>
    int(7)
  }
  public $opt =>
  NULL
```

増えたプロパティはnullになりそう

プロパティが減った場合、アクセス修飾子が変わった場合

Foo2.php

```php
<?php
class Foo
{
    protected $id;
    public function __construct(int $id)
    {
        $this->id = $id;
    }
}
```

```php
$ php serialize.php | php unserialize2.php
/tmp/php/unserialize2.php:8:
class Foo#1 (3) {
  protected $id =>
  int(3)
  protected $name =>
  string(3) "foo"
  public $attributes =>
  array(2) {
    'bar' =>
    string(3) "baz"
    [0] =>
    int(7)
  }
}
```

`protected`に変更した`$id`は`protected`に変更された
プロパティごと削除したものは`protected`、`public`を維持し復活する

シリアル化とはなんだ

シリアル化とは

>オブジェクトを格納するか、メモリ、データベース、またはファイルに転送するためにバイト ストリームに変換するプロセスです。
>[シリアル化 - Google 検索](https://www.google.com/search?ei=ZeN6Xai8H-eFr7wPq8GE6AQ&q=%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%AB%E5%8C%96&oq=%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%AB%E5%8C%96&gs_l=psy-ab.3...0.0..113...0.0..0.0.0.......0......gws-wiz.f47xeWGzNEM&ved=0ahUKEwjogq-CxszkAhXnwosBHasgAU0Q4dUDCAs&uact=5)