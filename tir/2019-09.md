# 2019-09

## 02

### [Vue\.js \- コンポーネントとイベントハンドラの動的交換を、 v\-ifを使わず実装する \- Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

ifを使わずコンポーネントを動的に切り替え、コンポーネントごとにイベントハンドリングの方法を変更する

```html
<div id="app">
  <h2>switch component and event handler:</h2>
  <ul>
    <li>
      <input type="radio" name="mapping" value="hoge" @input="onSelect"> hoge
    </li>
    <li>
      <input type="radio" name="mapping" value="fuga" @input="onSelect"> fuga
    </li>
    <li>
      <input type="radio" name="mapping" value="piyo" @input="onSelect"> piyo
    </li>
  </ul>
  <component :is="current.component" @click="onClick"></component>
</div>
```

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
const fuga = {
  component: Vue.extend({
    template: '<button @click="onClick">fuga</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('fuga')
  }
}
const piyo = {
  component: Vue.extend({
    template: '<button @click="onClick">piyo</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('piyo')
  }
}

new Vue({
  el: "#app",
  data: {
    current: hoge,
  },
  computed: {
    viewModelMap: function () {
        return {
        hoge, fuga, piyo
      }
    }
  },
  methods: {
    onClick: function () {
      this.current.onClick()
    },
    onSelect: function (event) {
      const viewModelKey = event.target.value

      this.mapping(viewModelKey)
    },
    mapping: function (viewModelKey) {
      const viewModel = this.viewModelMap[viewModelKey]

      if (!viewModel) {
        return
      }

      this.current = this.viewModelMap[viewModelKey]    
    }
  }
})
```

- `:is`プロパティ
  componentタグと合わせて、動的にコンポーネントを切り替える機能。`is`に指定されたタグかVueコンポーネントが作画される。
  `is`にはコンポーネント名やオプションオブジェクトの他`VueConstructor`を渡してもいい

- コンポーネント イベントハンドリングの対応関係をオブジェクト化

```js
const hoge = {
  component: Vue.extend({
    template: '<button @click="onClick">hoge</button>',
    methods: {
      onClick: function() {
        this.$emit('click')
      }
    }
  }),
  onClick() {
    alert('hoge')
  }
}
```

効果

- 子コンポーネントがシンプルかつステートレスに保てる
- パターンが増えたら、子コンポーネント イベントハンドリングの対応オブジェクトを追加するだけ
- 子コンポーネントだけ/イベントハンドリングの方法だけ、という単位で交換可能、個々の実装は変更不要

>「イベントハンドリングの内容」として 
 A\. コンポーネント依存の処理 
 B\. コンポーネント非依存の処理 
  という分別が存在し得ることを、明示的に認識していなかったからと思われる。  Aについては、それはコンポーネント自身に関わることであるから、自身の内部にその内容が記述されるべきだと思う（オブジェクトの状態を変更する場合に、setterを定義せず、内部にその手続きを閉じ込めるのと同じ）（まあ普段は新しいオブジェクトを作っちゃうけど、ここでは「変更しないといけない」ということで）。 これが外部に引き剥がされてしまうのと、それはコンポーネントに関する知識がコンポーネントの外部に流出してしまうことになるので、好ましくない。
 一方、Bはそもそもコンポーネント非依存なのだから、コンポーネントからは独立した状態 = 別モジュールとして定義/実装されているはず。 元々コンポーネントからは引き剥がされているのだから、それの呼び出し方が外部化されたとしてもそれは一枚層が増えただけで、状況は変わっていない。
>[Vue.js - コンポーネントとイベントハンドラの動的交換を、 v-ifを使わず実装する - Qiita](https://qiita.com/Philomagi/items/79d5447504a45e141f46)

オブジェクト化すれば後々楽になる

## 03

### [vee\-validate で「特定のフィールドに固有のバリデーションメッセージを設定する \- Qiita](https://qiita.com/ishiyama0530/items/106dfebe95165431f9e2)

特定のフィールドで、他の検証ルールに影響をあたえず、特定の検証ルールにのみバリデーションメッセージを設定する

lib/validatormessage

```js 
import { Validator } from 'vee-validate';

export function getError(
    validator: Validator,
    field: string,
    ruleMsssageMap: { [rule: string]: string }
): string | null {
    const errors = validator.errors.items.filter((e) => e.field === field);
    if (errors.length > 0) {
        const error = errors[0];
        let isExists = false;
        for (const rule in ruleMsssageMap) {
            if (error.rule === rule) {
                isExists = true;
            }
        }

        if (isExists) {
            return ruleMsssageMap[error.rule];
        } else {
            return validator.errors.first(field);
        }
    }

    return null;
}
```

```js
<template>
  <input
    type="text"
    name="myfield"
    v-model="myfieldValue"
    v-validate="{ required: true, regex: /[1-9]/ }"
  />
  <div v-show="myfieldError">
    {{ myfieldError  }}
  </div>
</template>
<script lang="ts">
import { getError } from '@lib/validatormessage'
...
computed: {
    myfieldError: {
      get: (): string | null => {
        return getError(this.$validator, 'myfield' { regex: 'cutome error message.' })
      },
    },
  },
<script>
```

myfieldErrorはバインドされており、変更された時、算出プロパティであるmyfieldErrorのget()が実行され、`lib/validatormessage`でエラー起きたruleと同じruleを探しメッセージを置き換える