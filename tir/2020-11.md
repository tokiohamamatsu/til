# 2020-11

## 02

### [C\#のインクリメント演算子(\+\+\)がスレッドセーフじゃないから色々調べた話。 \- Qiita](https://qiita.com/kami_teru/items/0cbd8b0ebcf02fa297d4)


スレッドセーフとはマルチスレッドプログラミングにおける概念で、スレッドセーフの場合、複数のスレッドが同時並行的に実行しても問題がないことをを表す。

[スレッドセーフ \(thread safe\)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word12456.html)

主題に書いているとおり、C#のインクリメント演算子はスレッドセーフではないらしい。

検証

MSTestで実行

```C#
public void TestIncrementersThreadSafe()
{
    var tasks = new List<Task>();
    int counter = 0;
    for (int i = 0; i < 250; i++)
    {
        tasks.Add(Task.Run(() => counter++));
    }
    Task.WaitAll(tasks.ToArray());
    Assert.AreEqual(250, counter);
}

// 結果 Assert.AreEqual に失敗しました。<250> が必要ですが、<247> が指定されました。
```

スレッドセーフを使いたい場合は、`System.Threading.Interlocked.Increment`を使用する。

```C#
public void TestIncrementersThreadSafe()
{
    var tasks = new List<Task>();
    int counter = 0;
    for (int i = 0; i < 250; i++)
    {
        tasks.Add(Task.Run(() => Interlocked.Increment(ref counter)));
    }
    Task.WaitAll(tasks.ToArray());
    Assert.AreEqual(250, counter);
}
```

[c\# \- How does Interlocked work and why is it faster than lock? \- Stack Overflow](https://stackoverflow.com/questions/18640327/how-does-interlocked-work-and-why-is-it-faster-than-lock)

上記の記事によると、InterlockedはCPUレベルでサポートされているそう。