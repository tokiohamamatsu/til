# 2020-11

## 02

### [C\#のインクリメント演算子(\+\+\)がスレッドセーフじゃないから色々調べた話。 \- Qiita](https://qiita.com/kami_teru/items/0cbd8b0ebcf02fa297d4)


スレッドセーフとはマルチスレッドプログラミングにおける概念で、スレッドセーフの場合、複数のスレッドが同時並行的に実行しても問題がないことをを表す。

[スレッドセーフ \(thread safe\)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word12456.html)

主題に書いているとおり、C#のインクリメント演算子はスレッドセーフではないらしい。

検証

MSTestで実行

```C#
public void TestIncrementersThreadSafe()
{
    var tasks = new List<Task>();
    int counter = 0;
    for (int i = 0; i < 250; i++)
    {
        tasks.Add(Task.Run(() => counter++));
    }
    Task.WaitAll(tasks.ToArray());
    Assert.AreEqual(250, counter);
}

// 結果 Assert.AreEqual に失敗しました。<250> が必要ですが、<247> が指定されました。
```

スレッドセーフを使いたい場合は、`System.Threading.Interlocked.Increment`を使用する。

```C#
public void TestIncrementersThreadSafe()
{
    var tasks = new List<Task>();
    int counter = 0;
    for (int i = 0; i < 250; i++)
    {
        tasks.Add(Task.Run(() => Interlocked.Increment(ref counter)));
    }
    Task.WaitAll(tasks.ToArray());
    Assert.AreEqual(250, counter);
}
```

[c\# \- How does Interlocked work and why is it faster than lock? \- Stack Overflow](https://stackoverflow.com/questions/18640327/how-does-interlocked-work-and-why-is-it-faster-than-lock)

上記の記事によると、InterlockedはCPUレベルでサポートされているそう。

## 04

### [C\# の Channel を学ぶ \(1\) \- Qiita](https://qiita.com/TsuyoshiUshio@github/items/059c5ef3792976d32c0c)

Channel(チャネル)はあるスレッドが別のスレッドと通信できるデータ構造のこと。

例

```C#
var ch = Channel.CreateUnbounded<string>();
```

```c#
var producer = Task.Run(async () =>
{
    var rnd = new Random();
    for (int i = 0; i < 5; i++)
    {
        Console.WriteLine($"Producer: waiting... ");
        await Task.Delay(TimeSpan.FromSeconds(rnd.Next(3)));
        Console.WriteLine("Writing to the channel");
        await ch.Writer.WriteAsync($"Message {i}");
    }
    ch.Writer.Complete();
});
```

producerでデータを生成し、ランダムにディレイしながら、メッセージを作成、completeでチャネルの終了を送信する流れ。

下記はConsumerでチャネルを読み込む。上記のcompleteメソッドがproducer側で呼ばれるまで、呼ばれるまで続ける。

```C#
var consumer = Task.Run(async () =>
{
    while (await ch.Reader.WaitToReadAsync())
        Console.WriteLine($"Consumer: {await ch.Reader.ReadAsync()}");
});
```

producerとconsumerは別スレッドで動いているが、チャネルを通じてデータを送付出来ている。

スレッドとはプログラムの処理の実行単位のこと。

[スレッド \(thread\)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word12453.html)

コードだけ見ると何やっているかわからなかった。