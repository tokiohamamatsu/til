# 2020-11

## 02

### [C\#のインクリメント演算子(\+\+\)がスレッドセーフじゃないから色々調べた話。 \- Qiita](https://qiita.com/kami_teru/items/0cbd8b0ebcf02fa297d4)


スレッドセーフとはマルチスレッドプログラミングにおける概念で、スレッドセーフの場合、複数のスレッドが同時並行的に実行しても問題がないことをを表す。

[スレッドセーフ \(thread safe\)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word12456.html)

主題に書いているとおり、C#のインクリメント演算子はスレッドセーフではないらしい。

検証

MSTestで実行

```C#
public void TestIncrementersThreadSafe()
{
    var tasks = new List<Task>();
    int counter = 0;
    for (int i = 0; i < 250; i++)
    {
        tasks.Add(Task.Run(() => counter++));
    }
    Task.WaitAll(tasks.ToArray());
    Assert.AreEqual(250, counter);
}

// 結果 Assert.AreEqual に失敗しました。<250> が必要ですが、<247> が指定されました。
```

スレッドセーフを使いたい場合は、`System.Threading.Interlocked.Increment`を使用する。

```C#
public void TestIncrementersThreadSafe()
{
    var tasks = new List<Task>();
    int counter = 0;
    for (int i = 0; i < 250; i++)
    {
        tasks.Add(Task.Run(() => Interlocked.Increment(ref counter)));
    }
    Task.WaitAll(tasks.ToArray());
    Assert.AreEqual(250, counter);
}
```

[c\# \- How does Interlocked work and why is it faster than lock? \- Stack Overflow](https://stackoverflow.com/questions/18640327/how-does-interlocked-work-and-why-is-it-faster-than-lock)

上記の記事によると、InterlockedはCPUレベルでサポートされているそう。

## 04

### [C\# の Channel を学ぶ \(1\) \- Qiita](https://qiita.com/TsuyoshiUshio@github/items/059c5ef3792976d32c0c)

Channel(チャネル)はあるスレッドが別のスレッドと通信できるデータ構造のこと。

例

```C#
var ch = Channel.CreateUnbounded<string>();
```

```c#
var producer = Task.Run(async () =>
{
    var rnd = new Random();
    for (int i = 0; i < 5; i++)
    {
        Console.WriteLine($"Producer: waiting... ");
        await Task.Delay(TimeSpan.FromSeconds(rnd.Next(3)));
        Console.WriteLine("Writing to the channel");
        await ch.Writer.WriteAsync($"Message {i}");
    }
    ch.Writer.Complete();
});
```

producerでデータを生成し、ランダムにディレイしながら、メッセージを作成、completeでチャネルの終了を送信する流れ。

下記はConsumerでチャネルを読み込む。上記のcompleteメソッドがproducer側で呼ばれるまで、呼ばれるまで続ける。

```C#
var consumer = Task.Run(async () =>
{
    while (await ch.Reader.WaitToReadAsync())
        Console.WriteLine($"Consumer: {await ch.Reader.ReadAsync()}");
});
```

producerとconsumerは別スレッドで動いているが、チャネルを通じてデータを送付出来ている。

スレッドとはプログラムの処理の実行単位のこと。

[スレッド \(thread\)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word12453.html)

コードだけ見ると何やっているかわからなかった。

## 05

### [【初心者向け】関数型プログラミングの基本原則 \- Qiita](https://qiita.com/takuya_tsurumi/items/a97313c48c6c05686dd1)

関数型プログラミングは純粋関数を宣言的に評価することがある。

純粋関数は、外部から観測可能な副作用を回避することで、不変性をもつプログラミングを生成する。

純粋関数には３つの原則がある。

- 宣言型
  - 目的の宣言だけを行い、細かい作業はコンピューターに任せる考え方
- 純粋関数
  -  入力する値が同じであれば、出力される値がお同じになる関数この特性を参照透過性という
  -  グローバル変数は使わない
  -  変更に強い
- 不変性
  - 一度生成すると変更出来ない 
  - Javascriptのobjectは不変性を持っていない。

純粋関数の原則に純粋関数があるのは疑問