# 2020-09

## 01

### [ElasticBeanstalkにLaravelアプリケーションをリリースするときのebextension設定 \- Qiita](https://qiita.com/kazuhei/items/295435f367c1a5d7a6af)


ElasticBeanstalkとはAWS ElasticBeanstalkのことで、インフラを気にしないでアプリ開発ができる。サービスのこと

インフラについて

[ITインフラ（システムインフラ）とは \- IT用語辞典 e\-Words](http://e-words.jp/w/IT%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9.html)

ElasticBeanstalkにリリースする場合は、`.ebextensions/*`にconfigファイルを置くことでリリース時のコマンドを追加することができる

```
container_commands:
  01-cache_config:
    command: "php artisan config:cache"
  02-cache_route:
    command: "php artisan route:cache"
  03-cache_view:
    command: "php artisan view:cache"
```

上記はconfigとroute、viewのキャッシュをアプリケーションをアップデートシた後に生成する。

container_commandsはApacheサーバーの再起動前に実行される。

## 02

### [Promiseをthrowするのはなぜ天才的デザインなのか \- Qiita](https://qiita.com/uhyo/items/255760315ca61544fe33)

使用言語:Javascript,Typescript

PromiseをthrowするAPIデザイン

これは、コンポーネントがレンダリング時にPromiseをthrowすることでレンダリングをサスペンドしたことを表す。(Promiseが解決されるまでレンダリングできないこと)

throwは大域脱出(実行をその場で集団し、外側に制御を移す)を伴う構文で、
大域脱出することは関数から返り値を返すのを放棄すること。

関数からの返り値を放棄することで、関数の返り値の型に影響をあたえず、関数の実行を中断できる。

例

```js

function getDataOrUndefined(): string | undefined {
 // ...
}

function getData(): string {
  const maybeData = getDataOrUndefined();
  if (maybeData === undefined) {
    throw new Error("あとは任せた！！！！！！！");
  }
  // ここでは maybeData は string型
  return maybeData;
}

```

上記の`getDataOrUndefined`はデータを取得する関数で、必ずstringを返す仕様にしたい、しかし、データがなければundefinedを返す。

これをthrowは解決することが出きる。

## 03

### [Try Catch文がとらえるのは"例外"である \- Qiita](https://qiita.com/yuu_j/items/fed8f687216ef471bc97)

結論から言うと、Try Catchでなんでも解決をしようとしないこと


例

```C#
try
    {
　　　　　# a,b共に、nullになる可能性がある
        var a = GetA();
        var b = GetB();
        # 変数bのnullチェックはしていない
        if(a != null)
        {
            var aHoge = a.GetHoge();
            var bHoge = b.GetHoge();
        }
    }
    catch
    {}
```

上記のコードは変数bがnullの場合、例外が発生する。

原因は変数bのnullチェックがされていないため

個人的にはtry-catchは保険程度に書いとけばいいと思った。

try-catchの他にtry-finaliyというものがある。

try-finaliyはtryブロックで例外が発生しても、finaliyブロック内のコードは実行される。

[try\-finally \- C\# リファレンス \| Microsoft Docs](https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/keywords/try-finally)

[【C\#】try\-catch\-finallyを使ってみよう \- Qiita](https://qiita.com/mik_claire/items/8f36d143639cd538a980)

## 04

### [C\#でCSVを出力するときの注意 \- Qiita](https://qiita.com/ikutana/items/39cd390415289ca758d2)

C#でCSVを出力するには下記の様に書くだけだが、文字コードの問題がある。

```C#
File.WriteAllLines(FileName, CSVData);
```

UTF-8で書き出しているはずが、ShiftJISとしてよんだ結果文字化けする。

解決方法はBOM付きのUTF-8を書き出すことで、書き出し方は`File.WriteAllLines`
の第三引数に`Encoding.Text.UTF8Encoding`をいれればBOM付きUTF-8で出力される。

BOMとはバイトオーダーマークの略称でこれはUnicodeで書かれていることの示す目印のこと

[バイトオーダーマーク \(BOM\)とは｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word11423.html)

## 07

### [【JavaScript】String配列の要素をキーとするオブジェクトを作成する方法 \- Qiita](https://qiita.com/impl_s/items/5b067e15181e0ad95bd0)

```js
const array = ['key1', 'key2', 'key3',]


const createObj = (array) => {
    const obj = new Object();
    array.forEach(item => (Object.defineProperty(obj, item, {
      enumerable: true, // ループのために必要!
      value: 'ここに値'
    })));
    return obj;
}

console.log(createObj(array));
// {key1: 'ここに値', key2: 'ここに値', key3: 'ここに値'}
```

Object.definePropertyはオブジェクトのプロパティを明示的に追加または変更できるもの。

[Object\.defineProperty\(\) \- JavaScript \| MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

definePropertyで定義されたオブジェクトの中身はimmutableで書き換えが負荷になる。書き換えをするには。writable属性をtrueにすることで、代入による書き換えができるようになる。

配列内の要素をキーとするオブジェクトを作成する方法は他にもあり

Object.fromEntriesを使ったやり方がある

```js
const array = ['key1', 'key2', 'key3',]


const createObj = array => Object.fromEntries(array.map(item => [item, 'ここに値']));

console.log(createObj(array));
```

Object.fromEntriesはキーと値のリストを取り、これらの項目から作成されたプロパティを持つ新しいオブジェクトを返す

[Object\.fromEntries\(\) \- JavaScript \| MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)

## 08

### [Gitのお悩み解決 \- Gitの気持ちになって考える checkout/merge/pull \- Qiita](https://qiita.com/turara/items/d3a3026d4463d8672bfb)

gitのコミットはその時点でのファイルの状態を保存すること

コミットの動作は

1. ファイルをインデックスに登録
2. ファイルがインデックスに登録された状態で、コミットを作成する

ブランチはコミットに貼り付けた付箋の役割を持つ

チェックアウトは今いる場所を指定したコミットに移動するコマンド
コミットを移動すると、ファイルの内容が移動前の状態から移動先のコミット作成時の状態に変更される。

チェックアウトするにはgitの管理下にあるファイルがコミットされた状態であることが条件で、エラーが発生する原因はコミットしていないファイルがあることにある。

マージは２つの変更履歴を合流させるコマンド

2つのブランチの変更を両方に摘要する

マージをするとコンフリクトが発生することがある

コンフリクトは２つの変更両方で、同じ名前のファイルは変更されたときに発生し
どちらかの変更を摘要するかユーザに委ねる。

詳しいことは参照先のページを見てほしい

## 09

### [コピペで簡単！NLogをすぐに使えるようにしたい人へ \- Qiita](https://qiita.com/hiesiea/items/f45e06d7c09dcd6577cf)

NLogはログ収集のプラットフォーム、ログの出力先や出力フォーマットの定義はconfigファイルで指定可能

[NLogでログを記録する \- Qiita](https://qiita.com/hsagae/items/9f09e6ee204745fd2481)

インストールするにはNuGetパッケージの管理からNLog.Configをインストールする

```
Install-Package NLog.Config
```

ログを出力するには各クラスでLoggerのインスタンスを生成する必要がある。

生成するのは手間なためラッパークラスを用意したほうがいいと思われる。