# 2020-05 

## 01

### [Choices\.jsをカスタマイズし、2行のセレクトボックスを作成する！ \- Qiita](https://qiita.com/tuubo/items/61bfc535062edbf50925)

Choise.jsとは軽量のセレクトボックスやテキスト入力を実装出来るスクリプト。

[Vanilla JSによる軽量なセレクトボックス、テキスト入力を実装できる「Choice\.js」 \| bl6\.jp](https://bl6.jp/web/javascript/choice-js/)

Choicesのセレクトボックスをカスタマイズ(カスタムテンプレート)する際は、callbackoncreatetemplatesの記述を変更する。

```js
const example = new Choices(element, {
  callbackOnCreateTemplates: function(template) {
    return {
      item: (classNames, data) => {
        // ここを変更する
      },
      choice: (classNames, data) => {
        // ここを変更する
      },
    };
  },
});
```

Choiseはユーザがっ選択可能な値select内の`<option></option>`に相当する。

itemは入力された値(text input)または選択された値に相当する。

2つの値をセレクトボックスに表示させる。

optionのtextとvalueはそれぞれdata.labelとdata.valueとして読み取られ、カスタムテンプレート内に書くことで、optionに設定した２つの値を表示させることが出来る。

```js
document.addEventListener('DOMContentLoaded', () => {
  new Choices('.js-choice', {
    shouldSort: false,
    callbackOnCreateTemplates: function(template) {
      return {
        item: (classNames, data) => {
          return template(`<div class="${classNames.item} ${
            data.highlighted
              ? classNames.highlightedState
              : classNames.itemSelectable
          } ${
            data.placeholder ? classNames.placeholder : ''
          }
          custom-select
          " data-item data-id="${data.id}" data-value="${data.value}" ${
            data.active ? 'aria-selected="true"' : ''
          } ${data.disabled ? 'aria-disabled="true"' : ''}>
            <span>No. ${data.value}</span>
            <span>${data.label}</span>
          </div>`);
        },
      choice: (classNames, data) => {
        return template(`
          <div class="${classNames.item} ${classNames.itemChoice} ${
          data.disabled ? classNames.itemDisabled : classNames.itemSelectable
        }
          custom-select
        " data-select-text="${this.config.itemSelectText}" data-choice ${
          data.disabled
            ? 'data-choice-disabled aria-disabled="true"'
            : 'data-choice-selectable'
        } data-id="${data.id}" data-value="${data.value}" ${
          data.groupId > 0 ? 'role="treeitem"' : 'role="option"'
        }>
            <span>No. ${data.value}</span>
            <span>${data.label}</span>
          </div>
        `);
      },
    };
  },
});
});
```

後はcssで２行のセレクトボックスが実現できる。

```css
.custom-select {
  display: flex;
  flex-direction: column;
}
```

## 07

### [2種類のフォーマットを含むCSVファイルの読み込み方 \- Qiita](https://qiita.com/tnishiki/items/b03e690b381800aa2b4e)

```
Id,Name
1,A社
2,B社

Name,Param1,Param2
A社,2019,20
A社,2020,19
B社,2019,10
```

1つめのフォーマットはIdとNameで、2つ目のフォーマットは、Name,Param1,Param2で1つ目のName項目に関するパラメータを扱っている。
フォーマット間は空行で区分けされている。ただし、空行は1行のみ

まず下記で空行の読み飛ばしを無効にする。これによりフォーマットの仕切りを認識できる。

```c#
csv.Configuration.IgnoreBlankLines = false;
```

次に、RegisterClassMapに2種類のマッピングクラスを登録し、それぞれのフォーマットの保存先を用意する。

```c#
// 登録
csv.Configuration.RegisterClassMap<TestData1Map>();
csv.Configuration.RegisterClassMap<TestData2Map>();

// 保存さきの用意
var TestData1Records = new List<TestData1>();
var TestData2Records = new List<TestData2>();
```

ヘッダ行かどうかを判断するフラグを定義し、空行と判斷する処理でもそれを使う。

```c#
//　空行と判斷した場合の処理
if (string.IsNullOrEmpty(csv.GetField(0)))
{
  isHeader = true;
  continue;
}
```

現在のヘッダ情報から、フォーマットを判別しそれぞれの保存先に格納する。想定しないヘッダの場合throwで例外が発生する。

```c#
switch (csv.Context.HeaderRecord[0])
{
  case "Id":
    TestData1Records.Add(csv.GetRecord<TestData1>());
    break;
  case "Name":
    TestData2Records.Add(csv.GetRecord<TestData2>());
    break;
  default:
    throw new InvalidOperationException("Unknown record type.");
}
```

1つ目のフォーマットで定義されたNameを使って、2つ目のフォーマットで定義される。Param1とParam2を表示する。

```c#
foreach (var l in TestData1Records)
{
  Console.WriteLine($"Id = {l.Id}, {l.Name}");
  foreach (var m in TestData2Records)
  {
    if (l.Name == m.Name)
    {
      Console.WriteLine($"Param1 = {m.Param1}, Param2 = {m.Param2}");
    }
  }
}
```

出力結果
```
Id = 1, A社
Param1 = 2019, Param2 = 20
Param1 = 2020, Param2 = 19
Id = 2, B社
Param1 = 2019, Param2 = 10
```

全体図

```c#
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using CsvHelper;
using CsvHelper.Configuration;

namespace MyProject
{
    class Program
    {
        static void Main(string[] args)
        {
            using (var reader = new StreamReader("test2.csv", Encoding.GetEncoding("SHIFT_JIS")))
            {
                using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
                {
                    csv.Configuration.IgnoreBlankLines = false;
                    csv.Configuration.RegisterClassMap<TestData1Map>();
                    csv.Configuration.RegisterClassMap<TestData2Map>();
                    var TestData1Records = new List<TestData1>();
                    var TestData2Records = new List<TestData2>();
                    var isHeader = true;
                    while (csv.Read())
                    {
                        if (isHeader)
                        {
                            csv.ReadHeader();
                            isHeader = false;
                            continue;
                        }

                        if (string.IsNullOrEmpty(csv.GetField(0)))
                        {
                            isHeader = true;
                            continue;
                        }

                        switch (csv.Context.HeaderRecord[0])
                        {
                            case "Id":
                               TestData1Records.Add(csv.GetRecord<TestData1>());
                               break;
                            case "Name":
                               TestData2Records.Add(csv.GetRecord<TestData2>());
                               break;
                            default:
                               throw new InvalidOperationException("Unknown record type.");
                        }
                    }
                    foreach (var l in TestData1Records)
                    {
                        Console.WriteLine($"Id = {l.Id}, {l.Name}");
                        foreach (var m in TestData2Records)
                        {
                            if (l.Name == m.Name)
                            {
                                Console.WriteLine($"Param1 = {m.Param1}, Param2 = {m.Param2}");
                            }
                        }
                    }
                }
            }
        }
        public class TestData1
        {
            public int Id { get; set; }
            public string Name { get; set; }
        }

        public class TestData2
        {
            public string Name { get; set; }
            public string Param1 { get; set; }
            public string Param2 { get; set; }
        }

        public sealed class TestData1Map : ClassMap<TestData1>
        {
            public TestData1Map()
            {
                Map(m => m.Id).Name("Id");
                Map(m => m.Name);
            }
        }

        public sealed class TestData2Map : ClassMap<TestData2>
        {
            public TestData2Map()
            {
                Map(m => m.Name).Name("Name");
                Map(m => m.Param1);
                Map(m => m.Param2);
            }
        }
    }
}
```

なぜ、ClassMapのmにデータが格納されるのだろうか?


## 08

### [F\# を知ってほしい \- Qiita](https://qiita.com/cannorin/items/59d79cc9a3b64c761cd4)

F#とはOCamlという言語をベースに開発されたプログラム言語

記事にはF#は色々な言語のいいとこ取りと書いてあるが、QiitaでF#のタグが付いた記事を見合いのはなぜだろうか？

そもそもの話OCmalとはなんだろうか?

J#を学ぶには先に多数の言語を学ぶ必要がありそう。