# 2019-11

## 01

### [phpの圧縮について \- Qiita](https://qiita.com/sota/items/07e8ad480556c9a43d77)

例

圧縮前

```php
    protected function _getUserList() {

        $userList = array();

        $key = __METHOD__;
        $cacheRes = Cache::read($key);
        if ( $cacheRes ) {
            $userList = $cacheRes;
            return $userList;
        }

        $userList = UserDb::selectUserList()
        $ret = Cache::save($key, $userList , 60);
        return $userList;
    }

# 保存内容は利用者に任せているのでバカでかいarrayとかが保存されがち
```

圧縮後

```php
   protected function _getUserList() {

        $userList = array();

        $key = __METHOD__;
        $cacheRes = Cache::read($key);
        if ( $cacheRes ) {
            $userList = json_decode(gzuncompress($cacheRes), true);
            return $userList;
        }

        $userList = UserDb::selectUserList()
        $comp = gzcompress(json_encode($userList))
        $ret = Cache::save($key, $comp, 60);
        return $userList;
    }
```

gzuncompressとは

圧縮された文字列を解凍する
[PHP: gzuncompress \- Manual](https://www.php.net/manual/ja/function.gzuncompress.php)


gzcompressとは

文字列を圧縮する

[PHP: gzcompress \- Manual](https://www.php.net/manual/ja/function.gzcompress.php)


圧縮と解凍はこうやるのか

## 05

### [firebaseのPromise内でthisを参照する方法 \- Qiita](https://qiita.com/noby111/items/c11c4dad5ed69e93a4d1)

firebaseとは

>Firebaseは、2011年にFirebase、Inc\.によって開発され、2014年にGoogleに買収されたモバイルおよびWebアプリケーション開発プラットフォーム
>[firebase - Google 検索](https://www.google.com/search?q=firebase&oq=firebase&aqs=chrome..69i57j0l5.3311j0j8&sourceid=chrome&ie=UTF-8)

Vue.jsのcomponent内でfirebaseのクエリを利用し、その結果をdata内に格納したいが、thenの中でthisを参照し、markerプロパティに代入したいがthisはundefinedといわれる

```js
export default {
  data () {
    return {
      markers: [],
    }
  },

  methods:{
    updateMarkers() {
      var db = firebase.firestore()
      var query = db.collection('markers')

      query.get()
        .then(function(snapshot){
          var markers = []
          snapshot.forEach(function(doc) {
            var marker = { position: doc.data().latLng }
            markers.push(marker)
          })
          this.markers = markers
        })
    },
  }
}
```

thisを一旦ローカル変数に格納し、promise内で参照させるようにする


```js
export default {
  data () {
    return {
      markers: [],
    }
  },

  methods:{
    updateMarkers() {
      var db = firebase.firestore()
      var query = db.collection('markers')
      var self = this

      query.get()
        .then(function(snapshot){
          var markers = []
          snapshot.forEach(function(doc) {
            var marker = { position: doc.data().latLng }
            markers.push(marker)
          })
          self.markers = markers 
        })
    },
  }
}
```

thisを一旦ローカル変数にに格納する技術は汎用性がありそう

## 06

### [JavaScriptのthisのスコープについて調べた \- Qiita](https://qiita.com/infr_0329/items/0b5f52eca738a6814c1a)

- 関数からの呼び出しの場合はthisはグローバルオブジェクトを参照している

```js
var test = 'nogi';

function myThis(){
  console.log(this);  // Window
  this.test = 'hoge';
}

myThis();
console.log(test);  // hoge
```

- メソッドからの呼び出しの場合はthisは属しているオブジェクトを参照する

```js
var test = 'yamada';

var myobj = {  
  test: 'taro',  
  myThis: function(){
    console.log(this);   // {test: "taro", myThis: ƒ}
    this.test = 'hanako';
  }
};

myobj.myThis();
console.log(myobj.test); // hanako
console.log(test); // yamada
```

- クラスからの呼び出しの場合はthisはプロパティもメソッドも属しているクラスを参照する


```js
var test = 'yamada';

class myClass{
  constructor(){
    this.test = 'taro';
    console.log(this); // myClass {test: "taro"}
  }

  myThis(){
    console.log(this);  // myClass {test: "taro"}
  }
}

var myobj = new myClass();
myobj.myThis();
console.log(test);  // yamada
```

しかし、クラス内に関数を定義するとthisはundefinedになる

- アロー関数からの呼び出しの場合はメソッドを呼び出しているオブジェクトを参照する

```js
var test = 'yamada';

var myobj = {
  test: 'taro',  
  myThis: function(){
    this.test = 'hanako';

    var arrow1 = function (){
      console.log(this.test);  // yamada
    }

    var arrow2 = () =>{
      console.log(this.test);  // hanako
    }

    arrow1();
    arrow2();
  }
};

myobj.myThis();
```

なぜ、クラスに関数を定義するとthisはundefinedになるのか？

## 07

### [[Vue] スライダーで割合を調整するUIを作成する \- Qiita](https://qiita.com/e_q/items/b3cdba2f532fbc298c8d)

vue-slider-componentとは

[カスタマイズ性の高いスライダー「vue\-slider\-component」の使い方 \| カバの樹](https://www.kabanoki.net/4621/)

```html
<div id="app">
    <button id="add" v-on:click="add">add</button>
  
    <button id="del" v-on:click="del">del</button><br><br>
    <vue-slider ref="slider" v-model="dots" :process="processFunc" :enable-cross="false">
    </vue-slider>
    <table>
      <th>item</th>
      <th>value</th>
      <tr v-for="(item, index) in items">
        <td> {{item}} </td>
        <td> {{getDots(index)}} </td>
    </table>
    
</div>
```

```js
new Vue({
  el: '#app',
  components: { "vue-slider": window['vue-slider-component'] },
  data: () => {
    return {
      items: ["item_0", "item_1", "item_2"],
      dots: [33,66],
      color:["red", "orange", "yellow", "green", "blue"],
      processFunc: dotsPos => {
        var array = [];
        if (dotsPos.length < 1) {
          return array;
        }

        var color = ["red", "orange", "yellow", "green", "blue"];

        array[0] = [0, dotsPos[0], { backgroundColor : color[0]}];
        for (var i = 1; i < dotsPos.length; i++) {
          array[i] = [dotsPos[i - 1], dotsPos[i], { backgroundColor : color[i % 5]}];
        }
        array[dotsPos.length] = [dotsPos[dotsPos.length - 1], 100, { backgroundColor : color[dotsPos.length % 5], disabled:true}];
        return array;
      },
    }
  },
  methods: {
    add: function () {
      this.items.push("item_" + this.items.length);
      this.setDots();
    },
    del: function() {
      this.items.pop();
      this.setDots();
    },
    setDots: function() {
      this.dots = [];
      if (this.items.length > 1) {
        var x = 100 / this.items.length;
        for (var i = 0; i < this.items.length - 1; i++) {
          this.dots.push(Math.floor(x * (i + 1)));
        }
        this.$refs.slider.setValue(this.dots);
      }
    },
    getDots: function(index) {
      if (this.items.length == 1) {
        return 100;
      } else if (index == 0) {
        return Array.isArray(this.dots) ? this.dots[0] : this.dots;
      } else if (index == this.items.length - 1) {
        return 100 - (Array.isArray(this.dots) ? this.dots[index - 1] : this.dots);
      }

      return this.dots[index] - this.dots[index - 1];
    }
  },
});
```

processFuncで返す配列が、各バーの始点・終点で、引数に点の位置が配列で入る

ツールチップ

```js
<template>
  <main id="app"
      <vue-slider ref="slider" v-model="dots" tooltip="none" :process="processFunc" :enable-cross="false">
        <template v-slot:process="{ start, end, style, index }">
          <div class="vue-slider-process" :style="style">
            <div :class="[
              'merge-tooltip',
              'vue-slider-dot-tooltip-inner',
              'vue-slider-dot-tooltip-inner-top',
            ]">
              {{ getRaito(index) }}
            </div>
          </div>
        </template>
      </vue-slider>
  </main>
</template>
<style>
  .merge-tooltip {
    position: absolute;
    left: 50%;
    bottom: 100%;
    transform: translate(-50%, -15px);
  }
</style>
```

ツールチップはこう作るんだな