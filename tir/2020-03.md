# 2020-03

## 02

### [JavaScriptオブジェクトで識別子として不正な名前のプロパティにアクセスする方法 \- Qiita](https://qiita.com/tetora1053/items/347fc7d7a99c5c5b5db5)


Javascript の識別子には英数字,$_のみを含めることができ、数字から始めてはいけないというきまりがある

オブジェクトのプロパティ名は識別子だが、内部的には文字列

文字列であれば、どのような値でも問題なく、識別子として有効である必要はない

プロパティ名は識別子として不正な内でもクオートで囲めばどんな名前でもエラーにはならないが、呼び出すときに注意が必要になる。

```js
const obj = {
  hoge: "ほげ", // 識別子として正しい名前なのでクオートで囲んでなくてもok
  "1hoge": "1ほげ", // 数字から始まっているがクオートで囲んでいるのでok
  "ho-ge": "ほーげ" // 識別子に含めることができない文字(-)が入っているがクオートで囲んでいるのでok
}
console.log(obj.hoge) // => ほげ
console.log(obj.1hoge) // エラー
console.log(obj.ho-ge) // エラー
```

識別子として、不正な名前が付けられているプロパティにドット法でアクセスしようとするとエラーになる

しかし、ブランケット記法を使う`オブジェクト名['プロパティ名']`という形でプロパティにアクセスする書き方

```js
const obj = {
  hoge: "ほげ",
  "1hoge": "1ほげ",
  "ho-ge": "ほーげ"
}
console.log(obj["1hoge"]) // => 1ほげ
console.log(obj["ho-ge"]) // => ほーげ
```

## 03

### [classインスタンスのメソッドに対して分割代入をすると、メソッド内でのthisの参照が失われるので注意 \- Qiita](https://qiita.com/abeyuya/items/698caf1c571116f6ef06)

javascript(ES6)の分割代入を利用する際に、classのメソッドを分割代入するとthisへの参照が失われて、thisにundefinedがセットされる

そのため、メソッド内でthisを参照している場合エラーになる

```js
console.log("--- test_class");

class DummyClass {
  constructor() {
    this.key = "value";
  }

  method() {
    console.log(this.key);
  }
};

const test_class = () => {
  const instance = new DummyClass();

  // これは問題ない
  instance.method();

  // これはエラーになる
  const { method } = instance;
  method();
};

test_class();
```

代入してもエラーになるがbindを使うことで動くことができる

```js
 // これはエラーになる
  const method = instance.method;
  method();

 // 動く
  const method = instance.method.bind(instance);
  method();
```

分割代入とは

```js
{a} = {a: "hoge"}
```

右辺にオブジェクト、左辺にオブジェクトのキーを書けば、値を取得できる

[js 分割代入 \{\} \- Qiita](https://qiita.com/kajirikajiri/items/e8fb8971281863401623)

## 04

### [SQL \| 分かりにくい JOIN / INNER JOIN / OUTER JOIN / LEFT JOIN / RIGHT JOIN の違い \- Qiita](https://qiita.com/Yinaura/items/3ab6fc49ae55f52e2d55)

SQLのJOINで使うのは実質三種類 
※ FULL OUTER JOIN,CROSS JOINのことは考えない
 - JOIN
 - RIGHT JOIN
 - LEFT JOIN

分類的にはINNER JOINは一種類だけでOUTER JOINは二種類ある

JOIN(INNER JOIN)は内部結合で結合出来なかった行は返さず、LEFT・RIGHT JOIN(LEFT・RIGHT OUTER JOIN)は外部結合で結合出来なかった行がある場合でも関係なく表示され、一部のレコードはnullになる。LEFT JOINは主テーブルに従うが、RIGHT JOINは従のテーブルを全て返す

### [初心者が押さえておくべきSQLガイド \- Qiita](https://qiita.com/Hailee/items/136439b53a1c4a8265b3)

データ検索クエリ

 - SELECT DISTINCT

重複を含まないデータを選択する

```sql
SELECT DISTINCT column1, column2, ...
FROM table_name;
```

 - GROUP BY 

特定のカラムをキーにした合計値や平均値などが表示される結果になる
集計間数 (COUNT,MAX,MIN,SUM,AVG)と一緒に使用される

GROUP BYとWHEREを一緒に使用した場合のSELECT文の実行順序

FROM → WHERE → GROUP BY → SELECT

 - Having

集計関数と一緒に使い、カラムを集計した結果を特定する条件 HavingとWHEREを区別する必要がある

 - IN
 
WHEREと一緒に使って、複数の値を指定できる

```sql
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
```

 - VIEW

仮想的なテーブルのこと、通常のSQLテーブルと同じように、レコードとカラムを含めており、VIEWは常にデータベース内の最新のデータを表示する

VIEWの作成

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

VIEWの削除

```sql
DROP VIEW <view_name>;
```

## 05

### [SQL文を書く時に気を付けていること \- Qiita](https://qiita.com/ta9star/items/339b87d8565b35ab8b9d)

早い段階で取得するデータを絞る

クエリを速くするには、とにかく早い段階で取得するデータ量を少なくする必要がある。

サブクエリをたくさん含む複雑なクエリを作成する場合も、最後にまとめてWHEREで絞るのではなく、サブクエリ内でレコード数も減らすことが重要

 - ルールベースのオプティマイザの場合は、WHEREは選択条件が少なくなる条件から記述する
   - 検索条件が複数ある場合、抽出する件数が少なくなる条件から記述する
   - インデックスが貼られていたり、カーディナリティ度が高い場合、それが先に評価されるので注意が必要。
 - 結合時にはあらかじめ結合の件数を減らす
 - ソート処理はできるだけ少ない件数で行う
 - 演算はできるだけ避ける

わからないこと

 - オプティマイザ

 - カーディナリティ