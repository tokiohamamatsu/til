# 2020-03

## 02

### [JavaScriptオブジェクトで識別子として不正な名前のプロパティにアクセスする方法 \- Qiita](https://qiita.com/tetora1053/items/347fc7d7a99c5c5b5db5)


Javascript の識別子には英数字,$_のみを含めることができ、数字から始めてはいけないというきまりがある

オブジェクトのプロパティ名は識別子だが、内部的には文字列

文字列であれば、どのような値でも問題なく、識別子として有効である必要はない

プロパティ名は識別子として不正な内でもクオートで囲めばどんな名前でもエラーにはならないが、呼び出すときに注意が必要になる。

```js
const obj = {
  hoge: "ほげ", // 識別子として正しい名前なのでクオートで囲んでなくてもok
  "1hoge": "1ほげ", // 数字から始まっているがクオートで囲んでいるのでok
  "ho-ge": "ほーげ" // 識別子に含めることができない文字(-)が入っているがクオートで囲んでいるのでok
}
console.log(obj.hoge) // => ほげ
console.log(obj.1hoge) // エラー
console.log(obj.ho-ge) // エラー
```

識別子として、不正な名前が付けられているプロパティにドット法でアクセスしようとするとエラーになる

しかし、ブランケット記法を使う`オブジェクト名['プロパティ名']`という形でプロパティにアクセスする書き方

```js
const obj = {
  hoge: "ほげ",
  "1hoge": "1ほげ",
  "ho-ge": "ほーげ"
}
console.log(obj["1hoge"]) // => 1ほげ
console.log(obj["ho-ge"]) // => ほーげ
```

## 03

### [classインスタンスのメソッドに対して分割代入をすると、メソッド内でのthisの参照が失われるので注意 \- Qiita](https://qiita.com/abeyuya/items/698caf1c571116f6ef06)

javascript(ES6)の分割代入を利用する際に、classのメソッドを分割代入するとthisへの参照が失われて、thisにundefinedがセットされる

そのため、メソッド内でthisを参照している場合エラーになる

```js
console.log("--- test_class");

class DummyClass {
  constructor() {
    this.key = "value";
  }

  method() {
    console.log(this.key);
  }
};

const test_class = () => {
  const instance = new DummyClass();

  // これは問題ない
  instance.method();

  // これはエラーになる
  const { method } = instance;
  method();
};

test_class();
```

代入してもエラーになるがbindを使うことで動くことができる

```js
 // これはエラーになる
  const method = instance.method;
  method();

 // 動く
  const method = instance.method.bind(instance);
  method();
```

分割代入とは

```js
{a} = {a: "hoge"}
```

右辺にオブジェクト、左辺にオブジェクトのキーを書けば、値を取得できる

[js 分割代入 \{\} \- Qiita](https://qiita.com/kajirikajiri/items/e8fb8971281863401623)

## 04

### [SQL \| 分かりにくい JOIN / INNER JOIN / OUTER JOIN / LEFT JOIN / RIGHT JOIN の違い \- Qiita](https://qiita.com/Yinaura/items/3ab6fc49ae55f52e2d55)

SQLのJOINで使うのは実質三種類 
※ FULL OUTER JOIN,CROSS JOINのことは考えない
 - JOIN
 - RIGHT JOIN
 - LEFT JOIN

分類的にはINNER JOINは一種類だけでOUTER JOINは二種類ある

JOIN(INNER JOIN)は内部結合で結合出来なかった行は返さず、LEFT・RIGHT JOIN(LEFT・RIGHT OUTER JOIN)は外部結合で結合出来なかった行がある場合でも関係なく表示され、一部のレコードはnullになる。LEFT JOINは主テーブルに従うが、RIGHT JOINは従のテーブルを全て返す

### [初心者が押さえておくべきSQLガイド \- Qiita](https://qiita.com/Hailee/items/136439b53a1c4a8265b3)

データ検索クエリ

 - SELECT DISTINCT

重複を含まないデータを選択する

```sql
SELECT DISTINCT column1, column2, ...
FROM table_name;
```

 - GROUP BY 

特定のカラムをキーにした合計値や平均値などが表示される結果になる
集計間数 (COUNT,MAX,MIN,SUM,AVG)と一緒に使用される

GROUP BYとWHEREを一緒に使用した場合のSELECT文の実行順序

FROM → WHERE → GROUP BY → SELECT

 - Having

集計関数と一緒に使い、カラムを集計した結果を特定する条件 HavingとWHEREを区別する必要がある

 - IN
 
WHEREと一緒に使って、複数の値を指定できる

```sql
SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
```

 - VIEW

仮想的なテーブルのこと、通常のSQLテーブルと同じように、レコードとカラムを含めており、VIEWは常にデータベース内の最新のデータを表示する

VIEWの作成

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

VIEWの削除

```sql
DROP VIEW <view_name>;
```

## 05

### [SQL文を書く時に気を付けていること \- Qiita](https://qiita.com/ta9star/items/339b87d8565b35ab8b9d)

早い段階で取得するデータを絞る

クエリを速くするには、とにかく早い段階で取得するデータ量を少なくする必要がある。

サブクエリをたくさん含む複雑なクエリを作成する場合も、最後にまとめてWHEREで絞るのではなく、サブクエリ内でレコード数も減らすことが重要

 - ルールベースのオプティマイザの場合は、WHEREは選択条件が少なくなる条件から記述する
   - 検索条件が複数ある場合、抽出する件数が少なくなる条件から記述する
   - インデックスが貼られていたり、カーディナリティ度が高い場合、それが先に評価されるので注意が必要。
 - 結合時にはあらかじめ結合の件数を減らす
 - ソート処理はできるだけ少ない件数で行う
 - 演算はできるだけ避ける

わからないこと

 - オプティマイザ

 - カーディナリティ

## 06

### [DBのオプティマイザまとめ \- Qiita](https://qiita.com/towtow/items/db397d39416adf9770aa)

オプティマイザはSQLを元にデータの取得処理を生成する機能。各DBで独自のオプティマイザを持つ。

SQLはどのテーブルからデータを取得するかを記述したものでDBからどのようにデータを取得するかは書いていない。

オプティマイザは現在のDBの状況から最も動作速度が早くなる処理を毎回決定している。DBからのデータ取得処理は重いため最適な処理をしなければ致命的な性能劣化が起こりうるそのための最適化処理のためにDBの状態から動的にデータ取得処理を生成するようになっている

オプティマイザがどのようなデータ取得処理を行うかは実行計画で確認できるが、統一規格がないため、各DBごとの実行計画の読み方を学ばないと読むことができない


オプティマイザはSQLを元にデータ取得処理を実行するので、SQLの改善はできないため、正しいSQLを作る必要がある。

SQLが正しい場合でもテーブルフルスキャンされる場合がある。原因としては、統計情報が古い場合がある。オプティマイザはデータ取得処理を作る時、DBの状態状態を統計情報から確認する。例として統計情報のレコード数は数件だが、実際が数万件の場合、インデックスにアクセスする時間を無駄だと考え、オプティマイザがテーブルフルスキャンを選ぶ場合がある。毎回DBの状態を確認しないのは状態確認は重い処理のため

回避策としては、統計情報を更新するかヒント句を用いて使用するインデックスを強制的に指定する方法がある

## 09

### [カーディナリティについてまとめてみた \- Qiita](https://qiita.com/soyanchu/items/034be19a2e3cb87b2efb)

カーディナリティは、カラムに格納されているデータの種類がどのくらいあるのか(カラムの値の種類の絶対値)のこと

カーディナリティは数学の集合論の濃度の意味

[cardinalityの意味・使い方・読み方 \| Weblio英和辞書](https://ejje.weblio.jp/content/cardinality)

カーディナリティが低い場合

性別なら男と女の二種類であり、カラムのデータの種類がテーブルのレコード数に比べて種類が少ない。このことを、カーディナリティが低いという

カーディナリティが高い場合

顧客番号ならたくさんの種類が存在することになり、カラムのデータのデータの種類が、テーブルのレコード数に比べて多い。このことをカーディナリティが高いという

インデックスは、基本的にカーディナリティが高い列に作成する。

複合インデックスの場合は、カーディナリティが高い順に貼っていく

こういう事案もあるらしい

[【MySQL忘備録1】【事件簿】 インデックスカーディナリティの罠 \- Qiita](https://qiita.com/thgm3116/items/a9a841a41ee26e15b29f)

インデックスについて

[MySQLでインデックスを貼る時に読みたいページまとめ\(初心者向け） \- Qiita](https://qiita.com/C058/items/1c9c57f634ebf54d99bb)

## 10

### [プログラムの可読性を上げるための条件分岐を減らす方法7個 \- Qiita](https://qiita.com/ddtaka/items/b178358ebc5b38c6906a)

使用言語 PHP

- ガード節

処理の対象外のと条件を、関数の先頭で、return,continueする方法
この後の、処理条件を限定することができる

```php
// 変更前
public function hoge($a, $b) {
    $result = 0;
    if (isset($a)) {
        $result = 1;
    } else {
        if (isset($b)) {
            $result = 2;
        }
    }
    return $result;
}

// 変更後
public function hoge($a, $b) {
    if (isset($a)) return 1;
    if (isset($b)) return 2;

    return 0;
}
```

- bool判定

基本的にtrue/falseを取得したい場合は、その条件を変数で返すだけで事足りる

```php
// 変更前
public function hoge($a) {
    if ($a === '') {
        return true;
    }
    return false;
}

// 変更後
public function hoge($a) {
    return $a === '';
}
```

- 配列利用

DBから値を取得してテキストを表示をしたいときに使う

```php
// 変更前
public function hoge($x) {
    $a = 0;
    switch ($x) {
        case 0:
            $a = '駅名1';
            break;
        case 1:
            $a = '駅名2';
            break;
        case 2:
            $a = '駅名3';
            break;
    }
    return $a;
}


// 変更後
public function hoge($x) {
    $array = [
        0 => '駅名1',
        1 => '駅名2',
        2 => '駅名3',
    ];
    return $array[$x];
}
```

- メソッド分割

１つのメソッドあたりの循環複雑度を減らす方法、根本的な解決ではない

三項演算子の活用

複雑な処理を書くことには適していない

- 型定義の実装

型を定義することで型を確認する必要がなくなる

```php
//　変更前
public function hoge($id) {
    if (!is_int($id)) {
        throw new \Exception('id must be type int');
    }

    $sql = "SELECT * FROM user WHERE user_id = {$id}";
    ...
}
// 変更後
public function hoge(int $id) {
    $sql = "SELECT * FROM user WHERE user_id = {$id}";
    ...
}
```

- 言語特有の演算子活用

phpの場合はnull合体演算子を活用して以下のようにコードを変更できる

```php
// 変更前
public function hoge($a) {
    $result = 0;
    if (!is_null($a)) {
        $result = $a;
    }
    return $result;
}

// 変更後
public function hoge($a) {
    return $a ?? 0;
}
```