# 2019-10

## 01

### [250行のVue\.jsで陣取りゲームを作った \- Qiita](https://qiita.com/miyauchoi/items/f3b382a24a1a63ecaa4f)

ゲームルール

自陣の中では矢印キーで動気回れる
敵陣の中では、縄を張りながら真っ直ぐ進む
縄を持ったまま自陣に戻ると、自陣が増える
敵が縄にぶつかるとゲームオーバー
自陣を増やすとスコアUP

黒色：プレイヤー
灰色：自陣
赤色：敵
白色：敵陣
茶色：縄


プログラム

html
``` html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>陣取りゲーム</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>

    <style>
        /* グリッドレイアウト */
        #grid {
            display: grid;
            grid-template-columns: repeat(20, 20px);    /* 横20マス 幅20px */
            grid-template-rows: repeat(20, 20px);   /* 縦20マス 高さ20px */
        }

        /* セルの色 */
        .cell {
            border: 1px solid white;
            background: whitesmoke;
        }

        /* ユーザーの陣地の色 */
        .cell.area {
            background: darkgray;
        }

        /* ロープの色 */
        .cell.lope {
            background: burlywood;
        }

        /* ユーザーの色 */
        .cell.user {
            background: black;
        }

        /* 敵の色 */
        .cell.enemy {
            background: orangered;
        }
    </style>
</head>
<body>
    <div id='app'>
        <p>SCORE: {{ score }}</p>

        <div id='grid'>
            <!-- セルを400個生成して、必要に応じてuser, area, lope, enemyクラスを付ける -->
            <!-- （注意：Vueは v-for="i in 数値" としたとき、iが1から始まる） -->
            <div v-for="i in grid.width * grid.height"
                 :class="{
                     cell: true,
                     area: user.area_indexes.includes(i - 1),
                     lope: user.lope_indexes.includes(i - 1),
                     user: user_index === i - 1,
                     enemy: enemy_index === i - 1,
                 }"
            ><!--{{ i - 1 }}--></div>
        </div>

        <p v-if='is_gameover'>
            GAME OVER<br>
            <button onclick="location.reload()">RETRY</button>
        </p>
    </div>

    <script>
        new Vue({
            el: '#app',

            data: {
                speed: 200, // 1マス進むのにかかる時間[ms]

                // グリッドのデータ
                grid: {
                    width: 20,  // 横20マス
                    height: 20, // 縦20マス
                },

                // ユーザーのデータ
                user: {
                    pos: { x: 0, y: 0 },    // 位置座標
                    direction: { dx: 1, dy: 0 },    // 進行方向（初期値は右）
                    area_indexes: [],   // ユーザーの陣地（インデックスの配列）
                    lope_indexes: [],   // ロープ（インデックスの配列）
                },

                // 敵のデータ
                enemy: {
                    pos: { x: 10, y: 10 },          // 位置座標
                    direction: { dx: -1, dy: 1 },   // 進行方向（初期値は左下）
                },
            },

            // 初期化
            created() {

                // 上下左右端をユーザーのエリアにする
                for(let x = 0; x < this.grid.width; x++) {
                    for(let y = 0; y < this.grid.height; y++) {
                        const is_side = x === 0 || x === this.grid.width - 1 || y === 0 || y === this.grid.height - 1

                        if(is_side) {
                            this.user.area_indexes.push(this.pos2index({x, y}))
                        }
                    }
                }

                // キーボード入力のイベントをon_keydownメソッドに投げる
                document.onkeydown = () => {
                    this.on_keydown(event.keyCode)
                }

                // 時間を動かし始める
                this.time_goes()
            },

            computed: {

                // スコア = ユーザーのエリアの量（初期の領域を除く）
                score() {
                    return this.user.area_indexes.length - this.grid.width * 2 - this.grid.height * 2 + 4
                },

                // ユーザーの座標をインデックスに変換
                user_index() {
                    return this.pos2index(this.user.pos)
                },

                // 敵の座標をインデックスに変換
                enemy_index() {
                    return this.pos2index(this.enemy.pos)
                },

                // ゲームオーバーの条件
                is_gameover() {
                    return this.user.lope_indexes.includes(this.enemy_index)
                },
            },

            methods: {
                // 時間を進める
                time_goes() {
                    if(this.is_gameover) return
                    this.forward_user()
                    this.forward_enemy()

                    setTimeout(this.time_goes.bind(this), this.speed)   // speedミリ秒後に自分自身を呼び出す
                },

                // 受け取った座標をインデックスに変換する
                pos2index({x, y}) {
                    return this.grid.width * y + x
                },

                // ユーザーを進める
                forward_user() {
                    const old_pos = { ...this.user.pos }

                    // directionの分だけ移動させる
                    this.user.pos.x += this.user.direction.dx
                    this.user.pos.y += this.user.direction.dy

                    const pos_owner = this.get_cell_owner(this.user.pos)    // 現在地の所有者

                    // 現在地が場外なら、位置座標を巻き戻す
                    if(pos_owner === 'frameout') {
                        this.user.pos = old_pos
                        return
                    }

                    // 現在地が敵陣の中なら、ここにロープを追加
                    if(pos_owner === 'enemy') {
                        this.user.lope_indexes.push(this.user_index)
                    }

                    // ロープを伸ばしたままユーザーの陣地まで辿り着いた場合
                    if(pos_owner === 'user' && this.user.lope_indexes.length) {

                        const enemy_area = this.get_enemy_area()

                        // 敵エリア以外のエリアをユーザーのエリアにする
                        this.user.area_indexes = []
                        this.user.lope_indexes = []
                        for(let x = 0; x < this.grid.width; x++) {
                            for(let y = 0; y < this.grid.height; y++) {

                                // このセル(x, y)が敵の陣地か否か
                                const is_enemy_area = enemy_area.left <= x && x <= enemy_area.right && enemy_area.top <= y && y <= enemy_area.bottom

                                if(is_enemy_area) continue
                                this.user.area_indexes.push(this.pos2index({x, y}))
                            }
                        }
                    }
                },

                // 敵を進める
                forward_enemy() {
                    const { pos, direction } = this.enemy

                    // ユーザーのエリアにぶつかるなら跳ね返す
                    const is_collided_x = this.get_cell_owner({ x: pos.x + direction.dx, y: pos.y }) === 'user'
                    const is_collided_y = this.get_cell_owner({ x: pos.x, y: pos.y + direction.dy }) === 'user'
                    if(is_collided_x) direction.dx *= -1    // 進行方向を左右反転
                    if(is_collided_y) direction.dy *= -1    // 進行方向を上下反転

                    // directionの分だけ移動させる
                    pos.x += direction.dx
                    pos.y += direction.dy
                },

                // 指定したセルの所有者を取得する
                get_cell_owner({x, y}) {
                    if(x < 0 || this.grid.width <= x || y < 0 || this.grid.height <= y) return 'frameout'
                    if(this.user.area_indexes.includes(this.pos2index({x, y}))) return 'user'
                    if(this.user.lope_indexes.includes(this.pos2index({x, y}))) return 'lope'
                    return 'enemy'
                },

                // 敵陣地の範囲（left, top, right, bottom）を取得する
                get_enemy_area() {
                    const { x, y } = this.enemy.pos
                    const area = { left: x, top: y, right: x, bottom: y }   // 初期値 = 敵自身の座標

                    // 上下左右それぞれの方向で敵陣地の範囲を調べる
                    while(this.get_cell_owner({x: area.left - 1, y}) === 'enemy') area.left--
                    while(this.get_cell_owner({x: area.right + 1, y}) === 'enemy') area.right++
                    while(this.get_cell_owner({x, y: area.top - 1}) === 'enemy') area.top--
                    while(this.get_cell_owner({x, y: area.bottom + 1}) === 'enemy') area.bottom++

                    return area
                },

                // キー入力を受け取ってユーザーの進行方向を変える
                on_keydown(keyCode) {
                    if(this.get_cell_owner(this.user.pos) !== 'user') return    // ユーザーのエリア外では方向転換できない

                    switch(keyCode) {
                        case 37: this.user.direction = {dx: -1, dy: 0}; break   // 「←」キーが押された
                        case 38: this.user.direction = {dx: 0, dy: -1}; break   // 「↑」キーが押された
                        case 39: this.user.direction = {dx: 1, dy: 0}; break    // 「→」キーが押された
                        case 40: this.user.direction = {dx: 0, dy: 1}; break    // 「↓」キーが押された
                    }
                },
            },
        })
    </script>
</body>
</html>
```

jintori.htmlなどの名前で保存して、ブラウザでそのファイルを開くと遊べる

デモページ

https://miyauchiakira.github.io/vue-game-jintori/

GitHub ソースコード

https://github.com/miyauchiakira/vue-game-jintori

配色は変えるべきだろうな

## 02

### [Vue\.jsでスクロール時のイベントを定義する \- Qiita](https://qiita.com/laineus/items/33d69cd211161e887ff1)

やりたいこと

ページを下のほうにスクロールしたらボタンを出す

下記のようにスクロールするたびに`created`と`destroyed`でイベントを登録・解除

```js
<script>
export default {
  created () {
    window.addEventListener('scroll', this.onScroll)
  },
  destroyed () {
    window.removeEventListener('scroll', this.onScroll)
  },
  methods: {
    onScroll () {
      // Do something
    }
  }
}
</script>
```

下記のようにするとスクロールした時のフックを定義できる

```js
<script>
export default {
  onScroll () {
    // Do something
  }
}
</script>
```

公式ドキュメントには上記のようなフックのカスタマイズは見つからないらしい

かわりに、グローバルな**Mixin**を作成

```js
// main.js
import Vue from 'vue'
// ..
import GlobalMixin from './GlobalMixin'

Vue.mixin(GlobalMixin)

// ..
```

```js
// GlobalMixin.vue
<script>
export default {
  mounted () {
    // Register onScroll event
    if (this.$options.onScroll) {
      window.addEventListener('scroll', this.$options.onScroll)
    }
  },
  destroyed () {
    // Unregister onScroll event
    if (this.$options.onScroll) {
      window.removeEventListener('scroll', this.$options.onScroll)
    }
  }
}
</script>
```

onScrollが定義されていた場合、windowのscrollイベントに登録し、destroyedで削除する。

各コンポーネントでonScrollという名前でイベントを定義する

```js
<script>
export default {
  data () {
    return {
      showButton: false
    }
  },
  onScroll () {
    this.showButton = window.scrollY > 100
  }
}
</script>
```

### Mixinってなに？

Mixinとは

>mixin とはオブジェクト指向プログラミング言語において、サブクラスによって継承されることにより機能を提供し、単体で動作することを意図しないクラスである。 言語によっては、その言語でクラスや継承と呼ぶものとは別のシステムとして mixin がある場合もある
>[Mixin - Google 検索](https://www.google.com/search?q=Mixin&oq=Mixin&aqs=chrome..69i57j69i61&sourceid=chrome&ie=UTF-8)

## 03

### [Vue\.js伸縮サイドバー \- Qiita](https://qiita.com/ShinichiroTakano/items/2f129f1c9be35f3d0d03)

流れ

1. サイドバーの横に設置したボーダー要素のmousedownイベントが発火する
2. mouseイベントを画面全体に登録し、画面上でポインターが動くたびに、handleMoveメソッドが呼ばれる。
3. handleMoveのメソッドの横幅が画面左端からポインターまでの距離の割合にする
4. ポインターの動きに合わせて、サイドバーが伸び縮みする

```js
//Page.vue
<template>
  <div id="page">
    <StretchableSidebar
      :isSidebarOpened="isSidebarOpened"
      :style="stretchableSidebarComputedStyle" />
    <SidebarBorder
      :isSidebarOpened="isSidebarOpened"
      @mousedown.native="startStretch"
      @toggle-sidebar="toggleSidebar" />
  </div>
</template>

<script>
import StretchableSidebar from './StretchableSidebar.vue'
import SidebarBorder from './SidebarBorder.vue'
const TOGGLE_BTN_WIDTH = 35
const DEFAULT_SIDEBAR_WIDTH = 0.2

export default {
  name: 'page',
  components: {
    StretchableSidebar,
    SidebarBorder
  },
  data() {
    return {
      stretchableSidebarStyle: {
        width: DEFAULT_SIDEBAR_WIDTH // 初期表示時の横幅は親要素の20%
      },
      pageRect: {
        width: 0,
        height: 0
      },
      toggleBtnStyle: {
        width: null
      }
    }
  },
  computed: {
    stretchableSidebarComputedStyle () {
      return { width: `${ this.stretchableSidebarStyle.width * 100 }%` }
    },
    isSidebarOpened () {
      return this.stretchableSidebarStyle.width > this.sidebarMinSize
    },
    sidebarMinSize () {
      // トグルボタンの横幅の割合の半分をサイドバーの最小値にする
      return this.toggleBtnStyle.width / 2
    }
  },
  mounted() {
    this.setScreenData()
    this.addResizeEvent()
  },
  beforeDestroy() {
    this.removeResizeEvent()
  },
  methods: {
    setScreenData () {
      this.setPageRect()
      this.setToggleBtnStyle()
    },
    setPageRect () {
      // サイドバーの親要素の横幅と高さを保存。
      const { width, height } = document.getElementById('page').getBoundingClientRect()
      this.pageRect.width = width
      this.pageRect.height = height
    },
    setToggleBtnStyle () {
      // 35px(ボタンの横幅)が親要素の横幅に対してどれぐらいの割合かを保存する。
      this.toggleBtnStyle.width = TOGGLE_BTN_WIDTH / this.pageRect.width
    },
    startStretch () {
      // 画面上でポインターを動かす度に、handleMoveが呼ばれるようにする。
      window.addEventListener('mousemove', this.handleMove)
      window.addEventListener('mouseup', this.finishStretch)
    },
    finishStretch () {
      window.removeEventListener('mousemove', this.handleMove)
      window.removeEventListener('mouseup', this.finishStretch)
    },
    handleMove (event) {
      const { pageX } = event
      const sidebarWidth = pageX / this.pageRect.width // サイドバーの親要素に対する横幅の割合 = 画面最左からポインターまでの距離 / 親要素の横幅
      if (sidebarWidth >= this.sidebarMinSize) {
        this.stretchableSidebarStyle.width = sidebarWidth
      } else {
        this.stretchableSidebarStyle.width = this.sidebarMinSize
        this.finishStretch()
      }
    },
    addResizeEvent () {
      window.addEventListener('resize', this.setScreenData)
    },
    removeResizeEvent () {
      window.removeEventListener('resize', this.setScreenData)
    },
    toggleSidebar () {
      if (this.stretchableSidebarStyle.width === this.sidebarMinSize) {
        this.stretchableSidebarStyle.width = DEFAULT_SIDEBAR_WIDTH
      } else {
        this.stretchableSidebarStyle.width = this.sidebarMinSize
      }
    }
  }
}
</script>

<style scoped>
#page {
  display: flex;
}
</style>
```

サイドバーの親要素のpageRectだけpx値を持ちサイドバーのwidthやトグルボタンのwidthはpageRect.widthを１とした時の割合で保持する

```js
//StretchableSidebar.vue
<template>
  <aside id="strechable-sidebar">
    <div :style="sidebarContentComputedStyle">
      <ul>
        <li>あああああ</li>
        <li>いいいいい</li>
        <li>ううううう</li>
      </ul>
    </div>
  </aside>
</template>
<script>
export default {
  name: 'stretchable-sidebar',
  props: {
    isSidebarOpened: {
      type: Boolean,
      required: true
    }
  },
  computed: {
    sidebarContentComputedStyle () {
      if (this.isSidebarClosed) {
        return { transform: `translateX(-${window.innerWidth}px)` }
      } else {
        return {}
      }
    },
    isSidebarClosed () {
      return !this.isSidebarOpened
    }
  }
}
</script>
<style scoped>
#strechable-sidebar {
  background-color: rgb(244, 245, 247);
  height: 100vh;
  overflow: hidden;
  user-select: none;
}
</style>
```

```js
//SidebarBorder.vue
<template>
  <div id="sidebar-border">
    <span id="sidebar-border-btn" @click.stop="toggleSidebar">
      <i :class="['fas', isSidebarOpened ? 'fa-chevron-left' : 'fa-bars']" />
    </span>
  </div>
</template>
<script>
export default {
  name: 'sidebar-border',
  props: {
    isSidebarOpened: {
      type: Boolean,
      required: true
    }
  },
  methods: {
    toggleSidebar () {
      this.$emit('toggle-sidebar')
    }
  }
}
</script>
<style scoped>
#sidebar-border {
  width: 3px;
  height: 100vh;
  position: relative;
}
#sidebar-border:hover {
  background-color: #708090;
  cursor: col-resize;
}
#sidebar-border-btn {
  width: 35px;
  height: 35px;
  background-color: #B0C4DE;
  border: 1px solid #708090;
  border-radius: 50%;
  display: inline-block;
  text-align: center;
  box-shadow: .5px .5px .5px rgba(0,0,0,0.6);
  position: absolute;
  top: 17.5px;
  left: -17.5px;
}
.fas {
  line-height: 35px;
  color: #696969;
}
.fa-chevron-left {
  cursor: w-resize;
}
.fa-bars {
  cursor: e-resize;
}
</style>
```

ページの割合はこう求めるのか

## 04

### [∞\_00002 \| 【Javascript】オブジェクト⇒配列の変換関数 \- Qiita](https://qiita.com/shim85pei/items/4893a5cec5af35c4b3cc)

オブジェクトを関数に、配列をオブジェクトに変換する

>描画内容をEWA（web上でExcelをいじる機能）に張り付けてダウンロード したいという要望
>[∞_00002 | 【Javascript】オブジェクト⇒配列の変換関数 - Qiita](https://qiita.com/shim85pei/items/4893a5cec5af35c4b3cc)

```js
var input={
    "00001":{userId:1234567,    userNm:"ほげ一郎",    country:"北海道"},
    "00002":{userId:2234567,    userNm:"ふが次郎",    country:"東京"},
    "00003":{userId:3334567,    userNm:"ごう三郎",    country:"滋賀"}
};
var output = [];


function objToArray( inputObject ){
    var outputArray=[];
    var i = 0;
    var j;

    for ( key1 in inputObject ){
       j=0;
       outputArray[i]= [];

       for ( key2 in inputObject[key1] ){
           outputArray[i][j] = inputObject[key1][key2];
           j++;
       }
       i++;
    }
    return outputArray;
}

output = objToArray(input);
console.log(output);//→[[1234567,ほげ一郎,北海道],[2234567,ふが次郎,東京][3334567,ごう三郎,滋賀]]
```

メインの処理の中では、オブジェクトを使用し、ページ上でデータの更新などをする。Excelに張り付けるときだけ上記の関数に投げ二次元配列にしてから、EWAも張り付け関数に渡せるので、対象オブジェクトの増減、プロパティの増減も気にしなくていい

オブジェクトを配列にはこうするんだ