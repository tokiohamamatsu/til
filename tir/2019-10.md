# 2019-10

## 01

### [250行のVue\.jsで陣取りゲームを作った \- Qiita](https://qiita.com/miyauchoi/items/f3b382a24a1a63ecaa4f)

ゲームルール

自陣の中では矢印キーで動気回れる
敵陣の中では、縄を張りながら真っ直ぐ進む
縄を持ったまま自陣に戻ると、自陣が増える
敵が縄にぶつかるとゲームオーバー
自陣を増やすとスコアUP

黒色：プレイヤー
灰色：自陣
赤色：敵
白色：敵陣
茶色：縄


プログラム

html
``` html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>陣取りゲーム</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>

    <style>
        /* グリッドレイアウト */
        #grid {
            display: grid;
            grid-template-columns: repeat(20, 20px);    /* 横20マス 幅20px */
            grid-template-rows: repeat(20, 20px);   /* 縦20マス 高さ20px */
        }

        /* セルの色 */
        .cell {
            border: 1px solid white;
            background: whitesmoke;
        }

        /* ユーザーの陣地の色 */
        .cell.area {
            background: darkgray;
        }

        /* ロープの色 */
        .cell.lope {
            background: burlywood;
        }

        /* ユーザーの色 */
        .cell.user {
            background: black;
        }

        /* 敵の色 */
        .cell.enemy {
            background: orangered;
        }
    </style>
</head>
<body>
    <div id='app'>
        <p>SCORE: {{ score }}</p>

        <div id='grid'>
            <!-- セルを400個生成して、必要に応じてuser, area, lope, enemyクラスを付ける -->
            <!-- （注意：Vueは v-for="i in 数値" としたとき、iが1から始まる） -->
            <div v-for="i in grid.width * grid.height"
                 :class="{
                     cell: true,
                     area: user.area_indexes.includes(i - 1),
                     lope: user.lope_indexes.includes(i - 1),
                     user: user_index === i - 1,
                     enemy: enemy_index === i - 1,
                 }"
            ><!--{{ i - 1 }}--></div>
        </div>

        <p v-if='is_gameover'>
            GAME OVER<br>
            <button onclick="location.reload()">RETRY</button>
        </p>
    </div>

    <script>
        new Vue({
            el: '#app',

            data: {
                speed: 200, // 1マス進むのにかかる時間[ms]

                // グリッドのデータ
                grid: {
                    width: 20,  // 横20マス
                    height: 20, // 縦20マス
                },

                // ユーザーのデータ
                user: {
                    pos: { x: 0, y: 0 },    // 位置座標
                    direction: { dx: 1, dy: 0 },    // 進行方向（初期値は右）
                    area_indexes: [],   // ユーザーの陣地（インデックスの配列）
                    lope_indexes: [],   // ロープ（インデックスの配列）
                },

                // 敵のデータ
                enemy: {
                    pos: { x: 10, y: 10 },          // 位置座標
                    direction: { dx: -1, dy: 1 },   // 進行方向（初期値は左下）
                },
            },

            // 初期化
            created() {

                // 上下左右端をユーザーのエリアにする
                for(let x = 0; x < this.grid.width; x++) {
                    for(let y = 0; y < this.grid.height; y++) {
                        const is_side = x === 0 || x === this.grid.width - 1 || y === 0 || y === this.grid.height - 1

                        if(is_side) {
                            this.user.area_indexes.push(this.pos2index({x, y}))
                        }
                    }
                }

                // キーボード入力のイベントをon_keydownメソッドに投げる
                document.onkeydown = () => {
                    this.on_keydown(event.keyCode)
                }

                // 時間を動かし始める
                this.time_goes()
            },

            computed: {

                // スコア = ユーザーのエリアの量（初期の領域を除く）
                score() {
                    return this.user.area_indexes.length - this.grid.width * 2 - this.grid.height * 2 + 4
                },

                // ユーザーの座標をインデックスに変換
                user_index() {
                    return this.pos2index(this.user.pos)
                },

                // 敵の座標をインデックスに変換
                enemy_index() {
                    return this.pos2index(this.enemy.pos)
                },

                // ゲームオーバーの条件
                is_gameover() {
                    return this.user.lope_indexes.includes(this.enemy_index)
                },
            },

            methods: {
                // 時間を進める
                time_goes() {
                    if(this.is_gameover) return
                    this.forward_user()
                    this.forward_enemy()

                    setTimeout(this.time_goes.bind(this), this.speed)   // speedミリ秒後に自分自身を呼び出す
                },

                // 受け取った座標をインデックスに変換する
                pos2index({x, y}) {
                    return this.grid.width * y + x
                },

                // ユーザーを進める
                forward_user() {
                    const old_pos = { ...this.user.pos }

                    // directionの分だけ移動させる
                    this.user.pos.x += this.user.direction.dx
                    this.user.pos.y += this.user.direction.dy

                    const pos_owner = this.get_cell_owner(this.user.pos)    // 現在地の所有者

                    // 現在地が場外なら、位置座標を巻き戻す
                    if(pos_owner === 'frameout') {
                        this.user.pos = old_pos
                        return
                    }

                    // 現在地が敵陣の中なら、ここにロープを追加
                    if(pos_owner === 'enemy') {
                        this.user.lope_indexes.push(this.user_index)
                    }

                    // ロープを伸ばしたままユーザーの陣地まで辿り着いた場合
                    if(pos_owner === 'user' && this.user.lope_indexes.length) {

                        const enemy_area = this.get_enemy_area()

                        // 敵エリア以外のエリアをユーザーのエリアにする
                        this.user.area_indexes = []
                        this.user.lope_indexes = []
                        for(let x = 0; x < this.grid.width; x++) {
                            for(let y = 0; y < this.grid.height; y++) {

                                // このセル(x, y)が敵の陣地か否か
                                const is_enemy_area = enemy_area.left <= x && x <= enemy_area.right && enemy_area.top <= y && y <= enemy_area.bottom

                                if(is_enemy_area) continue
                                this.user.area_indexes.push(this.pos2index({x, y}))
                            }
                        }
                    }
                },

                // 敵を進める
                forward_enemy() {
                    const { pos, direction } = this.enemy

                    // ユーザーのエリアにぶつかるなら跳ね返す
                    const is_collided_x = this.get_cell_owner({ x: pos.x + direction.dx, y: pos.y }) === 'user'
                    const is_collided_y = this.get_cell_owner({ x: pos.x, y: pos.y + direction.dy }) === 'user'
                    if(is_collided_x) direction.dx *= -1    // 進行方向を左右反転
                    if(is_collided_y) direction.dy *= -1    // 進行方向を上下反転

                    // directionの分だけ移動させる
                    pos.x += direction.dx
                    pos.y += direction.dy
                },

                // 指定したセルの所有者を取得する
                get_cell_owner({x, y}) {
                    if(x < 0 || this.grid.width <= x || y < 0 || this.grid.height <= y) return 'frameout'
                    if(this.user.area_indexes.includes(this.pos2index({x, y}))) return 'user'
                    if(this.user.lope_indexes.includes(this.pos2index({x, y}))) return 'lope'
                    return 'enemy'
                },

                // 敵陣地の範囲（left, top, right, bottom）を取得する
                get_enemy_area() {
                    const { x, y } = this.enemy.pos
                    const area = { left: x, top: y, right: x, bottom: y }   // 初期値 = 敵自身の座標

                    // 上下左右それぞれの方向で敵陣地の範囲を調べる
                    while(this.get_cell_owner({x: area.left - 1, y}) === 'enemy') area.left--
                    while(this.get_cell_owner({x: area.right + 1, y}) === 'enemy') area.right++
                    while(this.get_cell_owner({x, y: area.top - 1}) === 'enemy') area.top--
                    while(this.get_cell_owner({x, y: area.bottom + 1}) === 'enemy') area.bottom++

                    return area
                },

                // キー入力を受け取ってユーザーの進行方向を変える
                on_keydown(keyCode) {
                    if(this.get_cell_owner(this.user.pos) !== 'user') return    // ユーザーのエリア外では方向転換できない

                    switch(keyCode) {
                        case 37: this.user.direction = {dx: -1, dy: 0}; break   // 「←」キーが押された
                        case 38: this.user.direction = {dx: 0, dy: -1}; break   // 「↑」キーが押された
                        case 39: this.user.direction = {dx: 1, dy: 0}; break    // 「→」キーが押された
                        case 40: this.user.direction = {dx: 0, dy: 1}; break    // 「↓」キーが押された
                    }
                },
            },
        })
    </script>
</body>
</html>
```

jintori.htmlなどの名前で保存して、ブラウザでそのファイルを開くと遊べる

デモページ

https://miyauchiakira.github.io/vue-game-jintori/

GitHub ソースコード

https://github.com/miyauchiakira/vue-game-jintori

配色は変えるべきだろうな

## 02

### [Vue\.jsでスクロール時のイベントを定義する \- Qiita](https://qiita.com/laineus/items/33d69cd211161e887ff1)

やりたいこと

ページを下のほうにスクロールしたらボタンを出す

下記のようにスクロールするたびに`created`と`destroyed`でイベントを登録・解除

```js
<script>
export default {
  created () {
    window.addEventListener('scroll', this.onScroll)
  },
  destroyed () {
    window.removeEventListener('scroll', this.onScroll)
  },
  methods: {
    onScroll () {
      // Do something
    }
  }
}
</script>
```

下記のようにするとスクロールした時のフックを定義できる

```js
<script>
export default {
  onScroll () {
    // Do something
  }
}
</script>
```

公式ドキュメントには上記のようなフックのカスタマイズは見つからないらしい

かわりに、グローバルな**Mixin**を作成

```js
// main.js
import Vue from 'vue'
// ..
import GlobalMixin from './GlobalMixin'

Vue.mixin(GlobalMixin)

// ..
```

```js
// GlobalMixin.vue
<script>
export default {
  mounted () {
    // Register onScroll event
    if (this.$options.onScroll) {
      window.addEventListener('scroll', this.$options.onScroll)
    }
  },
  destroyed () {
    // Unregister onScroll event
    if (this.$options.onScroll) {
      window.removeEventListener('scroll', this.$options.onScroll)
    }
  }
}
</script>
```

onScrollが定義されていた場合、windowのscrollイベントに登録し、destroyedで削除する。

各コンポーネントでonScrollという名前でイベントを定義する

```js
<script>
export default {
  data () {
    return {
      showButton: false
    }
  },
  onScroll () {
    this.showButton = window.scrollY > 100
  }
}
</script>
```

### Mixinってなに？

Mixinとは

>mixin とはオブジェクト指向プログラミング言語において、サブクラスによって継承されることにより機能を提供し、単体で動作することを意図しないクラスである。 言語によっては、その言語でクラスや継承と呼ぶものとは別のシステムとして mixin がある場合もある
>[Mixin - Google 検索](https://www.google.com/search?q=Mixin&oq=Mixin&aqs=chrome..69i57j69i61&sourceid=chrome&ie=UTF-8)

## 03

### [Vue\.js伸縮サイドバー \- Qiita](https://qiita.com/ShinichiroTakano/items/2f129f1c9be35f3d0d03)

流れ

1. サイドバーの横に設置したボーダー要素のmousedownイベントが発火する
2. mouseイベントを画面全体に登録し、画面上でポインターが動くたびに、handleMoveメソッドが呼ばれる。
3. handleMoveのメソッドの横幅が画面左端からポインターまでの距離の割合にする
4. ポインターの動きに合わせて、サイドバーが伸び縮みする

```js
//Page.vue
<template>
  <div id="page">
    <StretchableSidebar
      :isSidebarOpened="isSidebarOpened"
      :style="stretchableSidebarComputedStyle" />
    <SidebarBorder
      :isSidebarOpened="isSidebarOpened"
      @mousedown.native="startStretch"
      @toggle-sidebar="toggleSidebar" />
  </div>
</template>

<script>
import StretchableSidebar from './StretchableSidebar.vue'
import SidebarBorder from './SidebarBorder.vue'
const TOGGLE_BTN_WIDTH = 35
const DEFAULT_SIDEBAR_WIDTH = 0.2

export default {
  name: 'page',
  components: {
    StretchableSidebar,
    SidebarBorder
  },
  data() {
    return {
      stretchableSidebarStyle: {
        width: DEFAULT_SIDEBAR_WIDTH // 初期表示時の横幅は親要素の20%
      },
      pageRect: {
        width: 0,
        height: 0
      },
      toggleBtnStyle: {
        width: null
      }
    }
  },
  computed: {
    stretchableSidebarComputedStyle () {
      return { width: `${ this.stretchableSidebarStyle.width * 100 }%` }
    },
    isSidebarOpened () {
      return this.stretchableSidebarStyle.width > this.sidebarMinSize
    },
    sidebarMinSize () {
      // トグルボタンの横幅の割合の半分をサイドバーの最小値にする
      return this.toggleBtnStyle.width / 2
    }
  },
  mounted() {
    this.setScreenData()
    this.addResizeEvent()
  },
  beforeDestroy() {
    this.removeResizeEvent()
  },
  methods: {
    setScreenData () {
      this.setPageRect()
      this.setToggleBtnStyle()
    },
    setPageRect () {
      // サイドバーの親要素の横幅と高さを保存。
      const { width, height } = document.getElementById('page').getBoundingClientRect()
      this.pageRect.width = width
      this.pageRect.height = height
    },
    setToggleBtnStyle () {
      // 35px(ボタンの横幅)が親要素の横幅に対してどれぐらいの割合かを保存する。
      this.toggleBtnStyle.width = TOGGLE_BTN_WIDTH / this.pageRect.width
    },
    startStretch () {
      // 画面上でポインターを動かす度に、handleMoveが呼ばれるようにする。
      window.addEventListener('mousemove', this.handleMove)
      window.addEventListener('mouseup', this.finishStretch)
    },
    finishStretch () {
      window.removeEventListener('mousemove', this.handleMove)
      window.removeEventListener('mouseup', this.finishStretch)
    },
    handleMove (event) {
      const { pageX } = event
      const sidebarWidth = pageX / this.pageRect.width // サイドバーの親要素に対する横幅の割合 = 画面最左からポインターまでの距離 / 親要素の横幅
      if (sidebarWidth >= this.sidebarMinSize) {
        this.stretchableSidebarStyle.width = sidebarWidth
      } else {
        this.stretchableSidebarStyle.width = this.sidebarMinSize
        this.finishStretch()
      }
    },
    addResizeEvent () {
      window.addEventListener('resize', this.setScreenData)
    },
    removeResizeEvent () {
      window.removeEventListener('resize', this.setScreenData)
    },
    toggleSidebar () {
      if (this.stretchableSidebarStyle.width === this.sidebarMinSize) {
        this.stretchableSidebarStyle.width = DEFAULT_SIDEBAR_WIDTH
      } else {
        this.stretchableSidebarStyle.width = this.sidebarMinSize
      }
    }
  }
}
</script>

<style scoped>
#page {
  display: flex;
}
</style>
```

サイドバーの親要素のpageRectだけpx値を持ちサイドバーのwidthやトグルボタンのwidthはpageRect.widthを１とした時の割合で保持する

```js
//StretchableSidebar.vue
<template>
  <aside id="strechable-sidebar">
    <div :style="sidebarContentComputedStyle">
      <ul>
        <li>あああああ</li>
        <li>いいいいい</li>
        <li>ううううう</li>
      </ul>
    </div>
  </aside>
</template>
<script>
export default {
  name: 'stretchable-sidebar',
  props: {
    isSidebarOpened: {
      type: Boolean,
      required: true
    }
  },
  computed: {
    sidebarContentComputedStyle () {
      if (this.isSidebarClosed) {
        return { transform: `translateX(-${window.innerWidth}px)` }
      } else {
        return {}
      }
    },
    isSidebarClosed () {
      return !this.isSidebarOpened
    }
  }
}
</script>
<style scoped>
#strechable-sidebar {
  background-color: rgb(244, 245, 247);
  height: 100vh;
  overflow: hidden;
  user-select: none;
}
</style>
```

```js
//SidebarBorder.vue
<template>
  <div id="sidebar-border">
    <span id="sidebar-border-btn" @click.stop="toggleSidebar">
      <i :class="['fas', isSidebarOpened ? 'fa-chevron-left' : 'fa-bars']" />
    </span>
  </div>
</template>
<script>
export default {
  name: 'sidebar-border',
  props: {
    isSidebarOpened: {
      type: Boolean,
      required: true
    }
  },
  methods: {
    toggleSidebar () {
      this.$emit('toggle-sidebar')
    }
  }
}
</script>
<style scoped>
#sidebar-border {
  width: 3px;
  height: 100vh;
  position: relative;
}
#sidebar-border:hover {
  background-color: #708090;
  cursor: col-resize;
}
#sidebar-border-btn {
  width: 35px;
  height: 35px;
  background-color: #B0C4DE;
  border: 1px solid #708090;
  border-radius: 50%;
  display: inline-block;
  text-align: center;
  box-shadow: .5px .5px .5px rgba(0,0,0,0.6);
  position: absolute;
  top: 17.5px;
  left: -17.5px;
}
.fas {
  line-height: 35px;
  color: #696969;
}
.fa-chevron-left {
  cursor: w-resize;
}
.fa-bars {
  cursor: e-resize;
}
</style>
```

ページの割合はこう求めるのか

## 04

### [∞\_00002 \| 【Javascript】オブジェクト⇒配列の変換関数 \- Qiita](https://qiita.com/shim85pei/items/4893a5cec5af35c4b3cc)

オブジェクトを関数に、配列をオブジェクトに変換する

>描画内容をEWA（web上でExcelをいじる機能）に張り付けてダウンロード したいという要望
>[∞_00002 | 【Javascript】オブジェクト⇒配列の変換関数 - Qiita](https://qiita.com/shim85pei/items/4893a5cec5af35c4b3cc)

```js
var input={
    "00001":{userId:1234567,    userNm:"ほげ一郎",    country:"北海道"},
    "00002":{userId:2234567,    userNm:"ふが次郎",    country:"東京"},
    "00003":{userId:3334567,    userNm:"ごう三郎",    country:"滋賀"}
};
var output = [];


function objToArray( inputObject ){
    var outputArray=[];
    var i = 0;
    var j;

    for ( key1 in inputObject ){
       j=0;
       outputArray[i]= [];

       for ( key2 in inputObject[key1] ){
           outputArray[i][j] = inputObject[key1][key2];
           j++;
       }
       i++;
    }
    return outputArray;
}

output = objToArray(input);
console.log(output);//→[[1234567,ほげ一郎,北海道],[2234567,ふが次郎,東京][3334567,ごう三郎,滋賀]]
```

メインの処理の中では、オブジェクトを使用し、ページ上でデータの更新などをする。Excelに張り付けるときだけ上記の関数に投げ二次元配列にしてから、EWAも張り付け関数に渡せるので、対象オブジェクトの増減、プロパティの増減も気にしなくていい

オブジェクトを配列にはこうするんだ

## 07

### [vue\.js ログイン前とログイン後でヘッダーの色を変える、サイドバーの表示非表示を切り替える \- Qiita](https://qiita.com/mah666hhh/items/54f8c24b62293da2ec0d)

ログインフォーム

- ログインのメソッドを定義

```js
// session/new.vue
methods: {
    loginUser: function() {
      axios
      .post('/login',
      {
        user: {
          email: this.user.email,
          password: this.user.password,
          password_confirmation: this.user.password_confirmation
        }
      })
      .then((res) => {
        console.log(res.data)
        this.$router.go({ path: this.currentRoutePath })
      }, (error) => {
        console.log(error)
      })
    }
  }
}
```

ヘッダーコンポーネント

- navbarの色を、v-bind:styleで動的に変化できるようにする

- コンポーネント内にログイン中のユーザーidを取得する(createdのタイミングで実行する)

- idを取得できればヘッダーの色が変わる

- ログイン後はサイドバーを表示させるため、$emitで親コンポーネントにisLoggedinというイベントを渡す

```js
// top.vue
<div class="navbar navbar-expand-lg" v-bind:style="{ background: navbarColor }">

<script>
  data: function() {
    return {
      current_user: {
        id: ''
      },
      navbarColor: '#696969'
    }
  },

created() {
    this.fetchCurrentUserId
},
computed: {
    fetchCurrentUserId: function() {
      axios
      .get('/api/users/sessions/fetch_current_user_id')
      .then((res) => {
        console.log(`fetch_current_user_id ${res.data}`)
        this.current_user.id = res.data
        if (this.current_user.id) {
          console.log(this.current_user.id)
          this.navbarColor = '#00ffff';
          this.$emit('isLoggedIn')
        }
      }, (error) => {
        console.log(error)
      })
    }
  }
}
</script>
```

親コンポーネント

- showSidebarプロパティを設定、これとv-showを利用しsidebarコンポーネントを非表示にする

- ヘッダーコンポーネントから受け取ったisLoggedlnイベントをきっかけにhandleShowSidebarメソッドを実行

- handleShowSidebarでshowSidebarプロパティをtrueにすることでサイドバーが表示される

```js
// scafold.vue
<top @isLoggedIn="handleShowSidebar" @isLogout="handleHideSidebar"></top>
<sidebar class="sidebar-area" v-show="showSidebar"></sidebar>

<script>
  data: function() {
    return {
      showSidebar: false
    }
  },
  methods: {
    handleShowSidebar: function() {
      console.log('handleShowSidebar called')
      this.showSidebar = true
    },
    handleHideSidebar: function() {
      console.log('handleHideSidebar called')
      this.showSidebar = false
    }
  }
</script>
```

ログアウト

- ログアウトしたら、ヘッダーの色を戻す

- isLogoutというイベントを親コンポーネントに渡し、handleHideSidebarを実行し、親コンポーネントのShowSidebarプロパティをfalseにしサイドバーを非表示にする

```js
// top.vue
    logoutUser: function() {
      axios
      // api/users/sessions#destroy
      .delete('/logout')
      .then((res) => {
        console.log(res.data)
        this.navbarColor = '#696969';
        this.$emit('isLogout')
        this.current_user = ''
        if (this.currentRoutePath === '/') {
          console.log('go called')
          this.$router.go({ path: this.currentRoutePath })
        }
      }, (error) => {
        console.log(error)
      })
    }
```

vue.jsのログイン処理はこう描くんだな

## 08

### [JavaScript の this を理解する多分一番分かりやすい説明 \- Qiita](https://qiita.com/takkyun/items/c6e2f2cf25327299cf03)

$(this)とは

thisはfunctionを呼んだ時の`.`の前についているものを指す

`.`が省略された場合はグローバルオブジェクトになる(non-strictモード時)。
strictモードではundefinedになる
サンプル

```js
function test() {
    console.log(this)
}
```

これをブラウザ上で呼び出すと

```js
test() // => Window {frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}
```

呼び出し時に`.`がないので、thisはグローバルオブジェクト、ブラウザではWindowオブジェクトになる(non-strict)モード

この関数testを特定のオブジェクトに結びつける

```js
function test() {
    console.log(this)
}
var obj = {}
obj.test = test
```

obj.test()を呼び出すと、thisはobjになる

```js
obj.test() // => {test: ƒ}
```

関数testを呼び出す際 `.`がついて`obj.`となっているので関数testの中でthis=objとなる

複数のfunctionを数珠つなぎで呼び出すメソッドチェーンは`.`の前は関数になるが、この場合、その関数が返すオブジェクトを参照する

関数でreturnを省略したり、return単独で呼ぶとundefinedが返ってくるから、メソッドチェーンは利用できない

```js
var obj = {
  test: function() { return this },
  alert: function(msg) { console.log(msg) }
}
var test = obj.test
obj.test().alert("hello") // => hello とコンソールに表示
test().alert("hello") // => アラート表示
```

関数alertの呼び出しに`.`があって、その前にtestがある。

関数testの返り値はthisなので、そのtestの呼び出し方によって参照されるオブジェクトにより関数aleatの結果が変わる

callやapplyを使って関数を呼び出すと`.`に前につけるものを指定できる

```js
function test() {
    console.log(this)
}
var obj = { name: "obj" }
test() // => Window {frames: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}
test.call(obj) // => {name: "obj"}
```

`test.call(obj)`は`obj.test()`に等しくなる(objにtestというメソッドは追加されない)


コンストラクタ

functionに対し、new構文を利用して、オブジェクトを作成できる

```js
var obj = new function() {
    this.name = "obj"
    console.log(this) // => {name: "obj"}
}
```

この時、functionが呼ばれているが、thisはグローバルオブジェクトでもundefinedでもない、newを使うと新規にオブジェクトを作成し、それに対し、callを使ってfunctionを呼び出して、関数内部で`return this`するような動作になる

```js
var obj = function() {
    this.name = "obj"
    console.log(this) // => {name: "obj"}
    return this
}.call({})
```

bind

bindは`.`ルールの挙動を変化させて、強制的にあるオブジェクトと結びつける

```js
function test() {
    console.log(this)
}
var obj = { name: "obj" }
var check = test.bind(obj)
check() // => {name: "obj"}
```

関数checkの呼び出しには`.`が付いていないが、bindされているので、呼び出し時に`obj.`が付く形となり、関数testの中でthis=objとなる

関数の中の関数

`.`はあくまでも関数呼び出し時に参照されるもの

```js
var obj = {
    test: function() {
        console.log(this) // *1
        function test() {
            console.log(this) // *2
        }
        test()
    }
}
obj.test()
```

*1の場合objがコンソールに表示され、*2ではグローバルオブジェクトが表示される(non-strictモード)

```js
var obj = {
    test: function() {
        console.log(this) // *1
        function test() {
            console.log(this) // *2
        }
        test.call(this)
    }
}
obj.test()
```

とcall(またはapply)を使えばどちらもobjとなる

### strictモードって何?

strictモードとは
[Strict モード \- JavaScript \| MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Strict_mode)

## 09

### [Laravel サービスプロバイダ \- Qiita](https://qiita.com/yebisu_heaven/items/2d0df4269590ba02897c)

サービスプロバイダとは

- laravelのサービスコンテナへのバインド処理で利用する機能
- フレームワークやアプリケーションに含まれるサービスの初期処理を行う。
- Laravelのライフサイクルでは、ビジネスロジックが実行される前に、サービスプロバイダのメソッドが呼ばれる

役割

- サービスコンテナへのバインド
- イベントリスナーやミドルウェア、ルーティングの登録
- 外部コンポーネントを組み込む

基本的な動作

- Laravelの初期処理で、各サービスプロバイダの`register`メソッドが実行される
- `register`メソッドでは、サービスコンテナへのバインドのみ行う(メソッドの実行タイミングでは、サービスコンテナから他の機能のインスタンスを取得する処理を実行できない)
- すべての`register`処理が終わると`boot`メソッドが呼ばれる
- `register`メソッドの実装は必須、`boot`メソッドは任意

#### deferプロパティによる遅延実行

- `defer`プロパティを`true`に設定することでアプリケーション起動時の`register`メソッドの実行を遅らせることができる
- `regster`メソッドの実行タイミングを指定するため、`provides`メソッドもしくは`when`メソッドで指定する必要がある

providesメソッド

- サービスコンテナで解決する文字列を指定する
- 文字列の解決をサービスコンテナに依頼したタイミングで、サービスプロバイダの`register`メソッドが呼ばれ、解決が行われる。

whenメソッド

- イベントを指定する
- 対象イベント名を配列で指定すると、リスナーが登録され、その中でサービスプロバイダの`register`メソッドが実行される。
- 設定したイベントが発行されると、このリスナーが発動して、`register`メソッドが実行される。

※ `provides`、`when`いずれの場合も、サービスコンテナでの解決やイベントのアプリケーション内で実行されるまで、インスタンス登録は行われない。

例

```php
class SampleServiceProvider extends ServiceProvider
{
    protected $defer = true;

    public function register()
    {
        $this->app->singleton('foo', function ($app) {
            return new Foo($app);
        });
        $this->app->singleton('bar', function ($app) {
            return new Bar($app);
        });
        $this->app->singleton('buzz', function ($app) {
            return new Buzz($app);
        });
    }

    public function provides()
    {
        return [
            'foo', 'bar', 'buzz'
        ];
    }
}
```

サービスプロバイダーの`provides`メソッドで、文字列を要素として配列を返している。ビジネスロジックで`foo`などのクラス名をサービスコンテナで解決すると、`register`メソッドが実行され、ロジック側にインスタンスが返される。

### サービスコンテナとは

>Laravelのサービスコンテナは、クラス間の依存を管理する強力な管理ツールです。依存注入というおかしな言葉は主に「コンストラクターか、ある場合にはセッターメソッドを利用し、あるクラスをそれらに依存しているクラスへ外部から注入する」という意味で使われます。
>[サービスコンテナ 5.7 Laravel](https://readouble.com/laravel/5.7/ja/container.html

## 10

### [Laravelで楽観的ロックをつくってみる \- Qiita](https://qiita.com/youstr/items/04018908522be2eda8ff)

悲観的ロックとは

自分がデータを取ってきた時点でロックをかけ、ほかの人はそのデータを取ってこれないようにする。

楽観的ロックとは

誰でもデータをとれるが、先に更新されると更新前のデータを更新できない

楽観的ロックの仕組み

1. 編集画面表示した時、hiddenに最終更新日時を持つ
2. 更新処理の直前に現在のレコードをselectして最終更新日時を取得する
3. hiddenの値 < 現在のレコードの値 だった場合他の人が更新しているのでエラーにする 

[※処理1：最終更新日時ではなくレコードのバージョンを保存するカラムを作って、更新のたびにインクリメントしていく方法もあります。  ※処理2〜3：レコードを更新する時の条件としてhiddenの値を指定して、更新結果が0件の場合はエラーとする方法もあるかと思います。](https://qiita.com/youstr/items/04018908522be2eda8ff)

```php
update blog set
    title = ?,   -- 入力値
    body = ?,  -- 入力
    edited_at = ?  -- CURRENT_TIMESTAMP()
where
    id = ?
    and
    edited_at = ? -- hiddenの日時
```

テーブル

```sql
CREATE TABLE `blog` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(30) DEFAULT NULL,
  `body` text,
  `edited_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

編集画面

```php
<form action="/save" method="post">
    @csrf
    <input type="hidden" name="edited_at" value="{{old('edited_at', $blog->edited_at??null)}}" />
    <input type="text" name="title" value="{{old('title', $blog->title??null)}}">
    <textarea name="body">{{old('body', $blog->body??null)}}</textarea>
</form>
```

更新処理

```php
<?php

namespace App\Services;

use App\Models\Blog;

class BlogService{

    /**
     * 保存
     *
     * @param array $values
     * @param Blog|null $blog
     */
    public function save(array $values, Blog $blog=null)
    {
        $input = collect($values);

        $model = $blog ?: new Blog();
        $model->title = $input->get('title');
        $model->body = $input->get('body');
        $model->setEditedAt($input->get('edited_at'));

        $model->save();
    }
}
```

$model->setEditedAt($input->get('edited_at'));で画面のhiddenに保持していた更新日時を設定する

楽観的ロック制御の仕組み

```php
<?php

namespace App\Models;

use App\Traits\OptimisticLockObserverTrait;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;


class Blog extends Model
{
    use SoftDeletes;
    use OptimisticLockObserverTrait;

    /**
     * 日付へキャストする属性
     *
     * @var array
     */
    protected $dates = [
        'created_at',
        'updated_at',
        'edited_at',
        'deleted_at',
    ];
}
```
use OptimisticLockObserverTrait;でトレイトを使いBlogモデルに2つのfunctionを定義する

```php
<?php

namespace App\Traits;

use App\Observers\OptimisticLockObserver;
use Carbon\Carbon;

trait OptimisticLockObserverTrait
{
    protected static function bootOptimisticLockObserverTrait()
    {
        self::observe(OptimisticLockObserver::class);
    }

    public function setEditedAt($editedAt){
        $this->{OptimisticLockObserver::OPTIMISTIC_LOCK_CHECK_COLUMN} = $editedAt? Carbon::parse($editedAt): null;
    }
}
```

setEditeAt()

BlogService#saveを呼び出していてこれを呼び出すとモデルオブジェクトに楽観的ロックチェック用の一時プロパティを追加し最終更新美を設定する

bootOptimisticLockObserverTrait()

- 修飾子がstaticであること
- function名がboot+クラス名であること

このルールで定義すると、modelクラスのコンストラクタでこのfunctionを実行してくれる

self::observe(OptimisticLockObserver::class);はオブサーバーをサービスプロバイダーではなくモデルで登録する機能

オブサーバとは

>特定のモデルに対し、多くのイベントをリスニングしている場合、全リスナのグループに対するオブザーバを一つのクラスの中で使用できます。オブザーバクラスは、リッスンしたいEloquentイベントに対応する名前のメソッドを持ちます。これらのメソッドは、唯一の引数としてモデルを受け取ります。
>[Eloquent：利用の開始 5.8 Laravel](https://readouble.com/laravel/5.8/ja/eloquent.html#observers)

hiddenの値 < 現在のレコードの値だった場合の処理

```php
<?php

namespace App\Observers;


use App\Exceptions\ExclusionException;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;

class OptimisticLockObserver
{
    /**
     * 楽観的ロックチェック用の一時プロパティ
     */
    const OPTIMISTIC_LOCK_CHECK_COLUMN = 'edited_at_optimistic_lock_check_column';


    /**
     * INSERT前
     *
     * @param Model $model
     */
    public function creating(Model $model){
        if (!$this->checkPropExists($model)) return;

        $this->unsetOptimisticLockColumn($model);
        $model->edited_at = Carbon::now();
    }

    /**
     * UPDATE前
     *
     * @param Model $model
     */
    public function updating(Model $model){
        if (!$this->checkPropExists($model)) return;

        $this->check($model, 'update');
        $model->edited_at = Carbon::now();
    }

    /**
     * 論理削除前
     *
     * @param Model $model
     */
    public function deleting(Model $model){
        if (!$this->checkPropExists($model)) return;

        $this->check($model, 'delete');
        $model->edited_at = Carbon::now();
    }

    /**
     * 物理削除前
     *
     * @param Model $model
     */
    public function restoring(Model $model){
        if (!$this->checkPropExists($model)) return;

        $this->check($model, 'delete');
        $model->edited_at = Carbon::now();
    }

    /**
     * 楽観的ロックチェック
     *
     * @param Model $model
     */
    private function check(Model $model, $msgType){
        //楽観的ロックチェック用の一時プロパティがあった時だけチェックする
        if (!$this->checkPropExists($model)) return;

        //現時点でのDBのデータを取得
        $currentMe = $model->withTrashed()->find($model->id);
        $currentEditedAt = $currentMe->edited_at;
        //更新されているかチェック
        if($model->{self::OPTIMISTIC_LOCK_CHECK_COLUMN} != $currentEditedAt){
            //楽観ロック
            throw new ExclusionException(trans('error_message.exclusion.'.$msgType));
        }

        $this->unsetOptimisticLockColumn($model);
    }

    /**
     * 楽観的ロック用の一時プロパティを削除する
     * これをしないと存在しないカラムに値を登録しようとしてsave()時にエラーになる。
     *
     * @param Model $model
     */
    private function unsetOptimisticLockColumn(Model $model){
        unset($model->{self::OPTIMISTIC_LOCK_CHECK_COLUMN});
    }

    /**
     * 楽観的ロック用の一時プロパティがあるかチェックする
     *
     * @param Model $model
     * @return bool true:ある
     */
    private function checkPropExists(Model $model){
        return array_key_exists(self::OPTIMISTIC_LOCK_CHECK_COLUMN, $model->getAttributes());
    }
}
```

モデルオブジェクトに楽観的ロックチェックのプロパティが存在したら、対象レコードのedited_atカラムの値をselectし、プロパティの値 < editd_atカラムの場合、ExclusionExceptionをスローする

楽観的ロックはこう作るのか

## 11

###  [PWAっていったい何？ \- Qiita](https://qiita.com/Rstta/items/2c60dca755065120d466)

#### PWAとは？

>PWAとは、「Progressive Web Apps」の略称で、モバイル向けWebサイトをGooglePlayストアなどで見かけるスマートフォン向けアプリのように使える仕組みです。PWAはそれ自体が何か特殊な一つの技術、というわけではありません。レスポンシブデザイン、HTTPS化など、Googleが定める要素を備えたWebサイトであり、オフラインやプッシュ通知に対応するためのブラウザAPI\(Service Workerなど\)を利用しているWebサイトをPWAと呼びます。
>[PWAとは（Progressive Web Appsとは） | SEO用語集：意味/解説/SEO効果など [SEO HACKS]](https://www.seohacks.net/basic/terms/pwa/)


#### PWAのメリット/デメリット

メリット

- インストール不要
  アプリではなくwebサービスのためインストールは必要ない
- オフラインでもある程度動ける
  キャッシュを使ってページ遷移などある程度動けるらしい
- プッシュ通知
  従来のwebサイトでは出来なかったプッシュ通知が可能になる

デメリット

- OS、ブラウザのバージョンによってはサポートされていないことがある
  Androidでは動くがiosだと動かない、Chromeなら動くがsafariでは動かないなど


#### 実装方法

1. httpsを有効にする
2. manifestを作る
3. ServiveWorkerを作る

詳細:  [PWAとは？実装方法・作り方を企業事例をもとに解説！ \| JAM25](https://jam25.jp/javascript/about-pwa/#outline__6)

オフラインでも動くのは便利

## 15

### [今すぐJavaScriptデバッグ効率を上げるconsoleテクニック \- Qiita](https://qiita.com/baby-degu/items/2c5cd103df54206ca401)

consoleオブジェクトを使えばブラウザのデバックコンソールにアクセスすることができる

javascriptをデバックする方法はconsole.log以外にもある

- console.count
  count()は引数をラベルとし、呼び出された回数を出力する。引数がない場合デフォルトのラベルを使用する

例

```js
function sayHello(name) {
  console.count()
  console.log(name)
}

sayHello("Indrek")
sayHello("William")
sayHello("Kelly")
```

- console.warn
  コンソールに警告メッセージを出力する

例

```js
function sayHello(name) {
  if(!name) {
    console.warn("No name given")
  }
}

sayHello()
```

- console.table
  配列やオブジェクトの表示に使う。テーブルがconsoleに出力される

例

配列の場合

```js
const fruits = ["kiwi", "banana", "strawberry"]

console.table(fruits)
```

オブジェクトの場合

```js
const pets = {
  name: "Simon",
  type: "cat"
};

console.table(pets);
```

2つのオブジェクトを1つの表にまとめる場合

```js
const pets = {
  name: "Simon",
  type: "cat"
};

const person = {
  firstName: "Indrek",
  lastName: "Lasn"
}

console.table([pets, person]);
```

2つのオブジェクトを配列に格納する

- console.group
  ネストブロック作成する。ネストの深さでデータを視覚的に関連付けれる

例

```js
console.log("This is the first level");
console.group();
console.log("Level 2");
console.group();
console.log("Level 3");
console.warn("More of level 3");
console.groupEnd();
console.log("Back to level 2");
console.groupEnd();
console.log("Back to the first level");
```

consoleオブジェクトはどうやってブラウザのデバックコンソールにアクセスするのか?

consoleオブジェクトはブラウザが持っている。

## 16

### [Node\.js: 外部パッケージを使わずに14行で作るHTTPリバースプロキシ \- Qiita](https://qiita.com/suin/items/0ca6d44c7671abdc032b)

```js
// typeScript
import {createServer, request} from 'http'

createServer((clientReq, clientRes) => {
  // クライアントから受け取ったリクエストを、バックエンドサーバに送る処理
  const serverReq = request({
    host: '127.0.0.1', // バックエンドHTTPサーバのホスト
    port: 9000, // バックエンドHTTPサーバのポート
    method: clientReq.method,
    path: clientReq.url,
    headers: clientReq.headers,
  }).on('error', () => clientRes.writeHead(502).end()) // バックエンドサーバとの通信エラーが発生した場合
    .on('timeout', () => clientRes.writeHead(504).end()) // バックエンドサーバとの通信がタイムアウトした場合
    .on('response', serverRes => {
      // バックエンドから受け取ったレスポンスをクライアントに送る処理
      // ステータスコードやヘッダをそのまま送る
      clientRes.writeHead(serverRes.statusCode!, serverRes.headers)
      // HTTPボディはストリームパイプで流す
      serverRes.pipe(clientRes)
    })
  // リクエストのHTTPボディはストリームパイプで流す
  clientReq.pipe(serverReq)
}).listen(8000) // リバースプロキシサーバのポート
```

1. リバースプロキシは普通のHTTPサーバーとして起動する。
2. リバースプロキシはクライアントからリクエストを受け取った時バックエンドサーバ向けのHTTPリクエストを生成する。
3. クライアントからのリクエストをコピーし、バックエンドにリクエストを送る
4. リバースプロキシは、バックエンドからレスポンスを受け取った時、それをクライアント向けのレスポンスにコピーし、クライアントにレスポンスを返す

**リバースプロキシとは**

>リバースプロキシ（英: Reverse proxy）または逆プロキシは、特定のサーバへのリクエストが必ず通過するように設置されたプロキシサーバである。一般的なプロキシとは逆で、不特定多数のクライアントのアクセスに備えて特定のサーバー専用に設けられる。
>[リバースプロキシ - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7)

**バックエンドとは**

>バックエンドとは、後部（の）、後端（の）、後置（の）、後工程（の）、最終段階（の）、などの意味を持つ英単語。ソフトウェアやシステムの構成要素のうち、利用者や他のシステム、ソフトウェアなどから見えないところでデータの処理や保存などを行う要素のことをこのように呼ぶ。
>[バックエンドとは - IT用語辞典 e-Words](http://e-words.jp/w/%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89.html)

## 17

### [PHP 複数の戻り値を指定する \- Qiita](https://qiita.com/clbcl226/items/06964e50d57b7535299f)

returnで配列化、listで渡す

```js
private function drinks(){
  $drink1 = "coffee";
  $drink2 = "tea";

  return array($drink1, $drink2);
  //または return [$drink1, $drink2];
}

list($drink1, $drink2) = $this->drinks();
```

return[]かreturn array()で配列で複数の戻り値を指定でき、list()で各戻り値を変数に格納する

複数の配列を戻り値に指定する

```js
private function drinks(){
  $softDrinks = ["tapioca milk tea", "cheese tea", "banana juice"]; //原宿とかで流行っているらしき飲み物
  $alcoholicBeverages = ["beer", "wine", "whisky"];

  return [$softDrinks, $alcoholicBeverages];
  //または　return array($softDrinks, $alcoholicBeverages);
}

list($softDrinks, $alcoholicBeverages) = $this->drinks();
```

やっていることは上記と同じ

新たに複数の配列を作成し戻り値に指定する

>menusテーブルがあり、name, category\(1 =foods, 2 =drinksの2種\), target\(対象者。1 =all\_ages, 2 =over\_20\)の3つのカラムがあるとする
>[PHP 複数の戻り値を指定する - Qiita](https://qiita.com/clbcl226/items/06964e50d57b7535299f)

```js
private function drinks(){
  //飲み物取得
  $drinks = $this->getDrinks();

  //戻り値に指定する、空の配列を用意
  $softDrinks = [];
  $alcoholicBeverages = [];

  //$drinksをループし、ターゲット別に各配列に追加していく
  foreach( $drinks as $drink ) {
    if( $drink['target'] == 1 ) {
      $softDrinks[] = $drink;
    } else {
      $alcoholicBeverages[] = $drink;
    }
  }
  //returnで配列化
  return [$softDrinks, $alcoholicBeverages]
}

list($softDrinks, $alcoholicBeverages) = $this->drinks();
```

list()で複数の変数に格納できる

>list — 配列と同様の形式で、複数の変数への代入を行う
>[PHP: list - Manual](https://www.php.net/manual/ja/function.list.php)

## 18

### [TypeScriptでVue\.setを型安全にしたい \- Qiita](https://qiita.com/simochee/items/4d31414cb612f96a4c9f)

vue.set
[API — Vue\.js](https://jp.vuejs.org/v2/api/#Vue-set)

Vue.setの型はvue/types/vue.d.tsに以下のように定義されている

```js
  set<T>(object: object, key: string | number, value: T): T;
  set<T>(array: T[], key: number, value: T): T;
```

配列は問題ないが、オブジェクトの値が本来の型と異なるものが設定できてしまう

型安全なVue.set

第2引数は第1引数で受け取るkeyを指定でき、第3引数は第2引数で指定した第1引数のkeyの値と同じ型を指定することができる

```js
  set<T extends object, K extends keyof T>(object: T, key: K, value: T[K]): T[K];
```

VueConstructorを拡張

Vue.setの型が定義されているvue/types/vue.d.tsのVueConstructorを拡張

TypeScriptは対象範囲すべての@types以下の型定義ファイルを自動でコンパイルする

```js
// src/@types/vue.d.ts
import Vue from 'vue';

declare module 'vue/types/vue' {
  interface VueConstructor {
    set<T extends object, K extends keyof T>(object: T, key: K, value: T[K]): T[K];
  }
}
```

>declare moduleは続くモジュール名（今回の場合はnode\_modules/vue以下のtypes/vue\.d\.tsを指定）の内部を拡張することができます。 declare module 'vue/types/vue' \{ \.\.\. \}の\{ \.\.\. \}内はvue/types/vue\.d\.tsでexportされているインターフェースをオーバーライドすることができます。
>[TypeScriptでVue.setを型安全にしたい - Qiita](https://qiita.com/simochee/items/4d31414cb612f96a4c9f)

しかし、これだけだと不正な値を設定できる

typeScriptのインターフェースの拡張は既にある定義を壊さない形での拡張のみ許され、型がマッチしなかった場合は後続でマッチする同じ型の型定義を探す

この場合安全な型チェックには引っかかたが、後続の安全ではない方の型チェックを通ったため設定できた



Vue.setの拡張は厳しそうだから、新しいグローバルメソッドを定義する

グローバルメソッドの追加方法は`Vue.newGlobalMethod = Function`のようにvueにプロパティをはやすだけ

```js
Vue.typedSet = (object: any, key: any, value: any) => Vue.set(object, key, value);
```

Nuxtを使用しているならプラグインを定義し、サーバーとクライアント双方で呼び出す

```js
import { Plugin } from '@nuxt/types';

const plugin: Plugin = (context, inject) => {
  Vue.typedSet = (object: any, key: any, value: any) => Vue.set(object, key, value);
});

export default plugin;
```

拡張した型定義のメソッド名をtypedSetに変更

```js
// src/@types/vue.d.ts
import Vue from 'vue';

declare module 'vue/types/vue' {
  interface VueConstructor {
    typedSet<T extends object, K extends keyof T>(object: T, key: K, value: T[K]): T[K];
  }
}
```

Nuxtを使用しない場合はどうするのか?

Vueでもプラグインは書けるらしい

[プラグイン — Vue\.js](https://jp.vuejs.org/v2/guide/plugins.html)

[【Vue\.js】ざっくり紹介、Vueプラグインの書き方 \- アシアルブログ](https://blog.asial.co.jp/2019/03/08/%E3%80%90Vue.js%E3%80%91%E3%81%96%E3%81%A3%E3%81%8F%E3%82%8A%E7%B4%B9%E4%BB%8B%E3%80%81Vue%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9)

## 21

### [ReactでブラウザーのStreams APIを使って、ダウンロードプログレスを表示する \- Qiita](https://qiita.com/jlkiri/items/c42e1a05e7e668482cc0)

Reactでデータを取得する場合、ローディングステート(データが取得されていない状態)と取得が終わった状態に分けられる。

Streams APIは取得がチャンクごとに制御でき、途中結果を表示できる。しかし、チャンクごとにステートの更新するとCPUに負荷が大きく表示されている画面の反応が悪くなる可能性がある。

Reactではなくrefを使う

以下で取得したバイト数とファイルのバイト数合計を使って、ダウンロードした割合をrefで表示する

```js
fetch(url)
      .then(response => {
        const contentLength = response.headers.get("content-length");

        let loaded = 0;

        const stream = new ReadableStream({
          start(controller) {
            const reader = response.body.getReader();
            return pump();

            function pump() {
              return reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                  return;
                }
                loaded += value.byteLength;

                progressRef.current.textContent = `${Math.round((loaded / contentLength) * 100)}%`;

                controller.enqueue(value);
                return pump();
              });
            }
          }
        });

        return new Response(stream);
      })
      .then(response => response.json())
      .then(data => console.log(data));
```

AbortControllerのabort()使えば止めるボタンが実装できる
navigator.connection.effectiveTypeでユーザの通信環境がわかるので取得前に途中プログレスするか、しないかの判断ができる。

Content-lengthヘッダーが欠けていることもあるので自分ので合計のバイト数を定数にするなど対策が必要

refとは

[Ref と DOM – React](https://ja.reactjs.org/docs/refs-and-the-dom.html)

Streams API

[Stream API入門 \- Qiita](https://qiita.com/Mizunashi_Mana/items/872354cd7bf25090932f)

## 23

### [【JavaScript】郵便番号から住所検索するWeb APIを使う練習 \- Qiita](https://qiita.com/K_Koh/items/8f1ab848f3beb8e31e5a)

郵便番号から住所を検索するAPI

郵便番号API zipcloudを使う

http://zipcloud.ibsnet.co.jp/


```js
$(function(){
  $('#btn').on('click', () => {
    $.ajax({
      url: "http://zipcloud.ibsnet.co.jp/api/search?zipcode=" + $('#postcode').val(),
      dataType: 'jsonp',
    }).done((data) => {
      if (data.results) { 
        getData(data.results[0]);
      } else {
        alert('該当データが見つかりません');
      }
    }).fail((data) => {
      alert('通信に失敗しました');
    });
  });

  function getData(data) {
    $('#pref').val(data.address1);
    $('#city').val(data.address2);
    $('#address').val(data.address3);
  }
});
```

$.ajaxでAjax通信をする。引数にはオブジェクト形式でパラメータを指定する
dataTypeには受け取るデータ形式を設定できる。この場合はjsonp形式を指定する。

jsonp形式とは

>JSONP \(JSON with padding\) とは、scriptタグを使用してクロスドメインな（異なるドメインに存在する）データを取得する仕組みのことである。HTMLのscriptタグ、JavaScript（関数）、JSONを組み合わせて実現される。
>[JSONP - Wikipedia](https://ja.wikipedia.org/wiki/JSONP)

取得したデータの中身

address1 :都道府県
address2 :市区町村
address3 :住所

ajaxは.doneで通信が成功した処理を書き、.failで通信が失敗した時の処理を書く

## 24

### [いちいち見出しに「必須入力」と書く労力 \- Qiita](https://qiita.com/yuetnus/items/218995043898923782bb)

inputタグにrequiredがついているものに自動的に必須と追記させる

```js
document.addEventListener('DOMContentLoaded',function(event){
    check_required();
},false);

function check_required()
{
    for(i=0;i<document.forms.length;i++){
        for(j=0;j<document.forms[i].elements.length;j++){
            e=document.forms[i].elements[j];
            if(e.attributes.getNamedItem("required")){
                e.placeholder+="[必須]";
                e.previousElementSibling.innerHTML+="[必須]";
            }
        }
    }
}
```

addEventListenerはイベントが対象に配信されるたびに呼び出される関数を指定する。この場合、DOMContentLoadedイベントで関数を実行する

DOMContentLoadedとは

>DOMContentLoaded イベントは、最初のHTMLドキュメントの読み込みと解析が完了した時に、スタイルシートや画像、サブフレームの読み込みが終わるのを待たずに発火します。全く違うloadイベントはすべてが読み込まれた時に発火する場合にのみ使用されるべきです。
>[DOMContentLoaded - イベントリファレンス | MDN](https://developer.mozilla.org/ja/docs/Web/Events/DOMContentLoaded)

document.forms.lengthでフォームの部品の数を取得できる。

`document.forms[i].elements[j];`で要素を取得する。

これは便利

## 25

### [ifやswitchが式じゃなくて困る時の対処 \- Qiita](https://qiita.com/xx2xyyy/items/9981e8441985392ec892)

javascriptのifやswitchは式ではなく文なので値を返さない

javascriptのifはconstの初期化時に条件に応じて値を入れるというケースに対応できない。switch文も同様

例

```js
// このコードは通らない

const hoge;
if(fuga){
 hoge = "fuga";
}else{
 hoge = "piyo";
}
```


三項演算子を使えば解決できるが、条件が多いときはコードがながくなる

```js
const hoge = fuga ? "fuga" : piyo ?  "piyo" : hogehoge ? "hogehoge" :"hogePiyo"
```

三項演算子以外の解決策としては関数に切り出すや即時関数がある。

関数に切り出す 例

```js
function decideFugaOrPiyo(fuga) {
  if(fuga){
    return "fuga";
  }
  return "piyo";
}
const hoge = decideFugaOrPiyo(fuga);
```

即時関数 例

```js
const hoge = (() => {
  if(fuga){
    return "fuga";
  }
  return "piyo";
})();
```

即時関数とは
>匿名関数を記述と同時に実行すること
>[【javascript】即時関数とは？ - Qiita](https://qiita.com/gooddoog/items/bef476a6697bf35e4577)


条件式の長さで解決策を変える

- 短い場合・シンプル->三項演算子
- 長い・複雑・再利用する->関数切り出し
- 中間->即時関数

状況で使い分ける必要があるんだな

## 28

### [対象要素までヌルッと自動スクロールするメソッドの書き方！ \- Qiita](https://qiita.com/allein-s/items/6dc21c1fdfab72f7d11a)

```js
// javascript

scrollToTarget() {
    const element = document.getElementById("target-id")
    const rect = element.getBoundingClientRect()
    const currentScrolledHeight = window.pageYOffset || document.documentElement.scrollTop
    const position = window.innerHeight * 0.9
    window.scrollTo({top: rect.bottom + currentScrolledHeight - position, behavior: "smooth"})
}
```

`.getBoundingClientRect()`で相対座標とサイズを取得できる

`window.pageYOffset`で垂直方法のスクロール量を取得できる

`documentElement.scrollTop`でどれだけ縦にスクロールしたかを取得できる
ある要素の下部の相対座標 + すでにスクロールされている高さ = ある要素の下部の絶対座標

window.scrollToは特定の座標までスクロールする。デフォルトだと一瞬でスクロールするが`behavior:"smooth"`を指定することでヌルッと動く

スクロールアニメーションはcssの`scroll-behavior:smooth;`のほうが便利っぽい

[スクロールアニメーションはJSではなくCSSのscroll\-behavior: smooth;が便利すぎてワロタ \- IQ90のマルチクリエイターK06のブログ](https://k06sblog.blog.fc2.com/blog-entry-74.html)

## 29

### [laravelのmigrationでintのカラムが勝手にAutoIncrementにされてハマった話 \- Qiita](https://qiita.com/haruraruru/items/8ed08a5dfd719ebb9a2e)

問題のマイグレーション

```php
  Schema::create('m_conf', function (Blueprint $table) {
            $table->increments('id')->unsigned()->nullable(false);
            $table->tinyInteger('type')->unsigned()->nullable(false)->default(1);
            $table->integer('watcher_id', 10)->nullable(false);
            $table->string('content', 200)->nullable(false);
            $table->char('created_from', 36)->nullable(false);
            $table->timestamps();
        });
```

起きるエラー
```
Syntax error or access violation: 1075 Incorrect table definition; there can be only one auto column and it must be defined as a key
```
Autoincrementを複数のカラムに指定した時のエラー

migrationが何をしているか

```php
//\vendor\laravel\framework\src\Illuminate\Database\Schema\Blueprint.php

    /**
     * Create a new integer (4-byte) column on the table.
     *
     * @param  string  $column
     * @param  bool  $autoIncrement
     * @param  bool  $unsigned
     * @return \Illuminate\Database\Schema\ColumnDefinition
     */
    public function integer($column, $autoIncrement = false, $unsigned = false)
    {
        return $this->addColumn('integer', $column, compact('autoIncrement', 'unsigned'));
    }
```

integer()の第2引数はAutoIncrementかどうか判断するもので、第3引数はunsignedを判断するもの。

integer()の引数は長さを指定するものではない


integer()第2引数に値を渡すとAutoIncrementになるんだ

## 30

### [Vueでのtextareaの自動拡縮を行うメソッドの書き方と、つまづいたところ \- Qiita](https://qiita.com/allein-s/items/7b6e4c20404bd9d673b7)

```html
<!--template-->

<textarea
    :value="value"
    @input="$emit('input', $event.target.value)"
    id="comment-area"
    style="min-height: 20px; overflow: hidden;"
    rows="1"
    @keydown="autoExpandTextarea"
/>
<button
  @click="$emit('input', '')"
>キャンセル
</button>
```

`rows`はデフォルトで2となっているので1に指定する

`min-height`で1行分の高さを指定する

自動拡縮時に一瞬スクロールバーが表示されることの対策で、`overfrow: hidden`を指定する

```js
// script

props: {
  value: {
    type: String,
    required: true
  },
}
watch: {
  value() {
    this.autoExpandTextarea()
  }
}
methods: {
  autoExpandTextarea() {
    const element = document.getElementById("comment-area")
    element.style.height = 'auto'
    if(this.value !== '') {
      element.style.height = element.scrollHeight + 'px'
    } else {
      element.style.height = '0'
    }
  }
}
```

`element.style.height='auto'`でいったん既存heightを上書き、その後、`element.style.height = element.scrollHeight + 'px'`で値を再設定することで自動拡縮をする。

>当初、watchでvalueを監視して、都度autoExpandTextareaを呼んでいたが、 かな入力時、未確定の文字が行を跨いだ際に、自動拡縮が行われなかった。 →@keydown="autoExpandTextarea"を設定で解決  @keydownから自動拡縮を呼び出すのであれば、watchは不要では？と思い消してしまったら、今度は、バックスペースやエンターなどに反応しなくなってしまった。 →@keydownとwatchを併用することに。  キャンセルボタンでフォームをクリア時に、element\.scrollHeightが更新されず、テキストエリアが縮まなかった →原因は不明のままだが、valueが空文字の際はelement\.style\.height = '0'としてmin\-heightまで縮小することで解決（ゴリ押し感）
>[Vueでのtextareaの自動拡縮を行うメソッドの書き方と、つまづいたところ - Qiita](https://qiita.com/allein-s/items/7b6e4c20404bd9d673b7)

element.scrollHeightとは

>スクロール分を含めた全体の高さを取得するプロパティ
>[Element.scrollHeight - スクロール分を含めた高さを取得する](https://syncer.jp/javascript-reference/element/scrollheight)

## 31

### [Object\.assign\(\)を用いてイミュータブルな変更を行う \- Qiita](https://qiita.com/bbapexx/items/3a5f11a893d8fe5dcda2)

ミュータブルな変更

javascriptではオブジェクトが格納されている変数を他の変数にコピーすると、そのオブジェクトへの参照がコピーされる。

イミュータブルな変更

参照先を変更したくない場合はObject.assign()を使う

```js
Object.assign(target, ...sources)
```

- target:コピー先のオブジェクト
- sources:コピー元オブジェクト

空のオブジェクトをコピー先オブジェクトにすることでオブジェクトのコピーができる。

```js
const gohan = { morning:"パン", lunch:"カレー", dinner:"ラーメン" }
const healthyGohan2 = Object.assign({}, gohan) // {}は空のオブジェクト
console.log(healthyGohan2) // { morning:"パン", lunch:"カレー", dinner:"ラーメン" }

healthyGohan2 == gohan // false
```

Object.assign()はオブジェクト同士の結合もできる

```js
const midnight = {midnight:"プロテイン"}
Object.assign(healthyGohan2, midnight)
console.log(healthyGohan2) // { morning:"パン", lunch:"カレー", dinner:"サラダ", midnight:"プロテイン" }
```

スプレッド演算子でもイミュータブルに扱うことができる。

```js
const healthyGohan3 = {...gohan}
console.log(healthyGohan3) // { morning:"パン", lunch:"カレー", dinner:"ラーメン" }
healthyGohan3 == gohan // false
```

Object.assign()よりスプレッド演算子のほうが楽そう。