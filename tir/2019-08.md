# 2019-08

## 01

### [PHPで型を意識し安全なプログラムを書く \- Qiita](https://qiita.com/minato-naka/items/cc9da5fc1bc8cc4240a8)

- phpの型を意識したプログラミング
    - 厳密な比較演算子(===)を使う
    - 普通の比較演算子(==)は自動的に型を変更して比較を行う

```php
var_dump('123' == 123);    // bool(true)
var_dump('123abc' == 123); // bool(true)
var_dump('abc' == 0);      // bool(true)

var_dump('123' === 123);    // bool(false)
var_dump('123abc' === 123); // bool(false)
var_dump('abc' === 0);      // bool(false)
```

- 比較系関数の厳密比較オプション

in_arrayなど比較を行う関数は普通の比較演算子を行う
  
```php
var_dump(
    in_array('xxx', ['aaa', 'bbb', 'ccc'])
);
// bool(false)

var_dump(
    in_array(123, ['aaa', 'bbb', '123ccc'])
);
// bool(true)
```

in_arrayの第3引数にtrueを設定すると厳密比較を行う

```php
var_dump(
    in_array(123, ['aaa', 'bbb', '123ccc'], true)
);
// bool(false)
```

in_array以外にもarray_searchやarray_keysなど厳密比較ができる

- 引数の型宣言

```php
function doubleInt(int $int) {  // ←この引数部分にintと記述すると型宣言できる
    return $int * 2;
}

echo doubleInt(5);      // 10
echo doubleInt('aaa');  // error
```

int型の引数を渡せば正常に動作するが、string型を渡した場合はエラーが起きる

- 返り値に型宣言をする

```php
function doubleInt(int $int): int {  // ←この部分で「: データ型」の形で返り値の型宣言をする
    return 'aaa';
}

echo doubleInt(5);  // error
```

宣言した型と違う型を返したらエラーになり、想定外のデータ型の値を返すことを防げる

- strict_types=1を使う

宣言した型と違う型を渡す(返す)とエラーになるは正確には違い可能な限り自動で型変換を行ってしまう

`declare(strict_types=1)`を使えば自動の型変換を防げる

```php
declare(strict_types=1);  // 強い型付けの設定

function doubleInt(int $int) {
    return $int * 2;
}

echo doubleInt('5');      // error
echo doubleInt(true);     // error
```

データ型のことを気にしてなかった

### [【初心者向け】JavaScriptの非同期処理を理解する　callback、Promiseそしてasync/awaitへ \- Qiita](https://qiita.com/G-awa/items/652107a9abf7ff6d0d06)

javascriptには非同期処理でファイルを読みこむ`fs.readFile`というメソッドが用意されている

```js
const fs = require('fs');

fs.readFile('data_001.json', 'utf-8', (err, data) => {
    console.log(data);
});
fs.readFile('data_002.json', 'utf-8', (err, data) => {
    console.log(data);
});
fs.readFile('data_003.json', 'utf-8', (err, data) => {
    console.log(data);
});
```

**結果**

```js
$ node callback.js
{
    "id": "3",
    "name": "steve"
}
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
```
非同期通信に実行されたので読み込み処理が完了したものからコンソールに出力される

順番にファイルを表示したい場合は以下のように記述する

```js
const fs = require('fs');

fs.readFile('data_001.json', 'utf-8', (err, data) => {
    console.log(data);
    fs.readFile('data_002.json', 'utf-8', (err, data) => {
        console.log(data);
        fs.readFile('data_003.json', 'utf-8', (err, data) => {
            console.log(data);
        });
    });
});
```

**結果**

```js
$ node callback.js
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
{
    "id": "3",
    "name": "steve"
}
```

例だ３つのファイルを読むだけだが、ネストが多くなるとソースの可読性落ちる

#### Promiseによる実装

本来は非同期処理の結果をコールバックで取得して、後続の処理につなげる方法だが、Promiseの解決方法は非同期処理の結果ではなく代わりにPromiseオブジェクトを返し処理が完了したら値を返す

```js
const fs = require('fs');

// 非同期処理を行い、Promiseを返却する関数を定義
function readFile(file) {
    return new Promise((resolve) => {
        fs.readFile(file, 'utf-8', (err, data) => {
            resolve(data)
        })
    })
}

readFile('data_001.json')
    .then((data) => {
        console.log(data);
        return readFile('data_002.json');
    })
    .then((data) => {
        console.log(data);
        return readFile('data_003.json');
    })
    .then((data) => {
        console.log(data);
    })
```

**結果**

```js
$ node promise.js
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
{
    "id": "3",
    "name": "steve"
}
```

`(処理).then(()=>{次の処理}`と繋ぐ必要がある

#### async/awaitによる実装

非同期処理で後続の実行を待たせたいときはawaitを関数を呼び出す前につける必要があり、また、awaitを使う関数にはasyncの記述する必要がある

```js
const fs = require('fs');

// 非同期処理を行い、Promiseを返却する関数を定義
function readFile(file) {
    return new Promise((resolve) => {
        fs.readFile(file, 'utf-8', (err, data) => {
            resolve(data)
        })
    })
}

async function readFiles() {
    data001 = await readFile('data_001.json');
    console.log(data001);
    data002 = await readFile('data_002.json');
    console.log(data002);
    data003 = await readFile('data_003.json');
    console.log(data003);
}

readFiles();
```

**結果**

```js
$ node async.await.js
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
{
    "id": "3",
    "name": "steve"
}
```

触れてみないとわからない

### [「ソースコード全部読まなきゃ病」と闘う方法 \- Qiita](https://qiita.com/guitar_char/items/3b31f7cc79333120b452)

- ソースを全部読まない読み方
  - Facedeを読む
    - 一番使う回数の多いところ周辺から徐々に理解していく
  - 必要なところだけ読む
    - 今知りたい知識が理解できたらそれより深く読まない、疑問が止まらない対象が出てきたら読む

こういう読み方があるんだ

## 02

### [PHPのintの最大値を超えた場合の挙動はどうなるか？ \- Qiita](https://qiita.com/a-nishimura/items/ce7d51202cc0a3eb38ec)

- intの最大値は32bitは約21億、64bitは約900京
- intの最大値を超えたらfloatになる

64bit

```php
$int_test = 9223372036854775807;
var_dump($int_test);
$int_test = 9223372036854775808;
var_dump($int_test);
```

**結果**

```php
int(9223372036854775807)
float(9.2233720368548E+18)
```

オーバーフローした値をintにキャストすると

```php
$int_test = (int)9223372036854775808;
var_dump($int_test);
```

**結果**

```php
int(-9223372036854775808)
```

`php_int_min`のintの最小値になった

オーバーフローするほどの値を扱うことがあるのだろうか？

### [Laravel View表示におけるview\(\)とredirect\(\)の違いについて \- Qiita](https://qiita.com/kajihara-kenji/items/3fe6c589d744a46912ae)

- view()は直接ファイルを呼び出す
- redirect()はRouteに沿ってViewを表示する

```php
Route::get('test-redirect', function () {
    return redirect('profile/index');
});

    /*上記、redirect('profile/index')から
        下記、get引数の'profile/index'へ*/

Route::get('profile/index', function () {
    return view('profile.index'); 
});
```

備忘録として残しておこう

## 05

### [暗号化したログをターミナルコマンドで復号化してみた \- Qiita](https://qiita.com/kusano00/items/3a31a0455e86122efd32)

- 暗号化

```php
use Log;//ログ出力に必要

$params = フォームで入力された値
$encryptParams = encrypt($params);
Log::info($encryptParams);
```

Log
```php
[2019-08-01 17:29:52] local.INFO: eyJpdiI6InFGbkpudVRpVjlMUjlhbnRFdTRRRGc9PSIs・・・　以下省略  
```

- 復号化

```php
use Log;//ログ出力に必要

public function handle()
    {
        //ログを復号化
        $contacts = $this->ask('Please enter a log command');//①コマンド実行時にユーザーに入力を尋ねる
        //②ユーザーが暗号化されたログを入力
        $decryptParams = Crypt::decrypt($contacts);//③入力値を復号化
        print_r($decryptParams);//ターミナル画面に復号化したデータを出力
    }
```

`encrypt`で暗号化し`decrypt`で復号化するんだな

### [Laravel5.8 Controller上でデータ取得後、新しくプロパティを追加する \- Qiita](https://qiita.com/siophp/items/48d18b5b03397930ca3a)

- controllerでプロパティを追加する

`$object->新しいプロパティ名＝〇〇`

※これだけではプロパティを保存したり、テーブルのカラムを書き換えたりすることができない

```php
public function index()
    {
      $posts = Post::with('likes')->latest()->paginate(20);
      $user_id = Auth::id();
      if($user_id){
        foreach($posts as $post){
          foreach($post->likes as $like){
            if($like->user_id===$user_id){
              //新しく追加するプロパティ
              $post->liked_id = $like->id;
            }
          }
        }
      }
      return view('index')->with('posts',$posts);
    }
```

dd(post)でpostのattributesを確認するとプロパティが確認できる

プロパティの追加前

```php
attributes: array:5 [▼
    "id" => 18
    "created_at" => "2005-11-09 09:04:07"
    "updated_at" => "1999-11-01 17:05:26"
    "body" => "Libero nihil eum nam suscipit."
    "user_id" => 4
  ]
```

プロパティの追加後

```php
attributes: array:6 [▼
    "id" => 18
    "created_at" => "2005-11-09 09:04:07"
    "updated_at" => "1999-11-01 17:05:26"
    "body" => "Libero nihil eum nam suscipit."
    "user_id" => 4
    "liked_id" => 6
  ]
```

新しいプロパティは既存のプロパティと同じように`$post->propaty`で使える

controllerでプロパティを追加できるんだ

## 06

### [Laravel 6 が来るぞ！！ & Serverless Laravel Vapor も来るぞ！！ \- Qiita](https://qiita.com/il-m-yamagishi/items/2eee25e05fdf6b9a6c8b)

- 互換性はlaravel4からlaravel5に上がった時は互換性をガン無視らしい
  が、larabel5から6に上がる時はそうはならないこと
- リリース時期は8月中
- 新機能はLaravel Vaporとの親和性を高めるための機能が追加されていそう。また、Vue3.0との連携も考えられていそうな雰囲気(Vue3.0のリリースはまだかかりそう)

>Laravel Vapor は、Laravel用のサーバーレスプラットフォームで、サーバーへのデプロイやオートスケーリングに対応し、Laravelアプリケーションで利用する全てのインフラをカバーします。
>[[Laravel Vapor] Laravel Vaporが発表されました | Xzxzyzyz](https://vapor.laravel.com/)

laravel6が出るのか

### [input type="file"でCall to a member function hashName\(\) on nullのエラーが出た時の対処 \- Qiita](https://qiita.com/ishi_ken1115/items/455dce970bf6265c8bad)

- `input type="file"`は元々の値を保持できない
- 画像が空の状態で渡ってしまうと`Call to a member function hashName() on null`というエラーが出る
- ファイルのアップロード有無を条件分岐したら解消できる

エラー時

```php
public function update(Request $request, User $user)
    {
        $image = $request->file('avatar_image');
        // バケットのuploadsフォルダにアップロード
        $path = Storage::disk('s3')->putFile('uploads', $image, 'public');
        // アップした画像のフルパスを取得
        $user->avatar_image = Storage::disk('s3')->url($path);
    }
```

エラー対処後

```php
public function update(Request $request, User $user)
    {
        if($request->has('avatar_image')) { //このif文を追記
            $image = $request->file('avatar_image');
            // バケットのuploadsフォルダにアップロード
            $path = Storage::disk('s3')->putFile('uploads', $image, 'public');
            // アップした画像のフルパスを取得
            $user->avatar_image = Storage::disk('s3')->url($path);
        }
    }
```
$request->has(avatar_image)でアップロードの有無がわかるんだ

## 07

### [PHP For Beginnersチュートリアル　その9　PHP関数の基本 \- Qiita](https://qiita.com/shitikakei/items/0b3d675f123bf1622831)

- 引数の設定

```php
 <?php 

function sum ($num1,$num2=0) {

    echo $num1+$num2;
    echo "<br>";

}

sum(5);
sum(6);
sum(1);

 ?> 
```
関数の引数に予め値を設定でき、呼び出す時省略できる

- 関数内の変数へのアクセス

下2つのコードはエラーになる

```php
<?php

function sum ($num1=0,$num2) {

    $total = $num1 + $num2;

}

$n1 = 10;
$n2 = 20;
sum($n1+$n2);
echo $total;
 ?>
```

```php
$n1 = 10;
$n2 = 20;

function sum () {

    echo $n1 + $n2;

}

sum($n1,$n2);
```

関数の中の変数は外からアクセスすることができない仕様、クラスやオブジェクトにも同じことが言える。
アクセスするにはgrobal変数に設定する

```php
$n1 = 10;
$n2 = 20;

function sum () {

    global $n1,$n2;
    $n1=14;
    echo $n1 + $n2;
        echo "<br>"

}

sum($n1,$n2);
echo $n1;
```

phpの基本の一部を学び直せた