# 2019-08

## 01

### [PHPで型を意識し安全なプログラムを書く \- Qiita](https://qiita.com/minato-naka/items/cc9da5fc1bc8cc4240a8)

- phpの型を意識したプログラミング
    - 厳密な比較演算子(===)を使う
    - 普通の比較演算子(==)は自動的に型を変更して比較を行う

```php
var_dump('123' == 123);    // bool(true)
var_dump('123abc' == 123); // bool(true)
var_dump('abc' == 0);      // bool(true)

var_dump('123' === 123);    // bool(false)
var_dump('123abc' === 123); // bool(false)
var_dump('abc' === 0);      // bool(false)
```

- 比較系関数の厳密比較オプション

in_arrayなど比較を行う関数は普通の比較演算子を行う
  
```php
var_dump(
    in_array('xxx', ['aaa', 'bbb', 'ccc'])
);
// bool(false)

var_dump(
    in_array(123, ['aaa', 'bbb', '123ccc'])
);
// bool(true)
```

in_arrayの第3引数にtrueを設定すると厳密比較を行う

```php
var_dump(
    in_array(123, ['aaa', 'bbb', '123ccc'], true)
);
// bool(false)
```

in_array以外にもarray_searchやarray_keysなど厳密比較ができる

- 引数の型宣言

```php
function doubleInt(int $int) {  // ←この引数部分にintと記述すると型宣言できる
    return $int * 2;
}

echo doubleInt(5);      // 10
echo doubleInt('aaa');  // error
```

int型の引数を渡せば正常に動作するが、string型を渡した場合はエラーが起きる

- 返り値に型宣言をする

```php
function doubleInt(int $int): int {  // ←この部分で「: データ型」の形で返り値の型宣言をする
    return 'aaa';
}

echo doubleInt(5);  // error
```

宣言した型と違う型を返したらエラーになり、想定外のデータ型の値を返すことを防げる

- strict_types=1を使う

宣言した型と違う型を渡す(返す)とエラーになるは正確には違い可能な限り自動で型変換を行ってしまう

`declare(strict_types=1)`を使えば自動の型変換を防げる

```php
declare(strict_types=1);  // 強い型付けの設定

function doubleInt(int $int) {
    return $int * 2;
}

echo doubleInt('5');      // error
echo doubleInt(true);     // error
```

データ型のことを気にしてなかった

### [【初心者向け】JavaScriptの非同期処理を理解する　callback、Promiseそしてasync/awaitへ \- Qiita](https://qiita.com/G-awa/items/652107a9abf7ff6d0d06)

javascriptには非同期処理でファイルを読みこむ`fs.readFile`というメソッドが用意されている

```js
const fs = require('fs');

fs.readFile('data_001.json', 'utf-8', (err, data) => {
    console.log(data);
});
fs.readFile('data_002.json', 'utf-8', (err, data) => {
    console.log(data);
});
fs.readFile('data_003.json', 'utf-8', (err, data) => {
    console.log(data);
});
```

**結果**

```js
$ node callback.js
{
    "id": "3",
    "name": "steve"
}
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
```
非同期通信に実行されたので読み込み処理が完了したものからコンソールに出力される

順番にファイルを表示したい場合は以下のように記述する

```js
const fs = require('fs');

fs.readFile('data_001.json', 'utf-8', (err, data) => {
    console.log(data);
    fs.readFile('data_002.json', 'utf-8', (err, data) => {
        console.log(data);
        fs.readFile('data_003.json', 'utf-8', (err, data) => {
            console.log(data);
        });
    });
});
```

**結果**

```js
$ node callback.js
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
{
    "id": "3",
    "name": "steve"
}
```

例だ３つのファイルを読むだけだが、ネストが多くなるとソースの可読性落ちる

#### Promiseによる実装

本来は非同期処理の結果をコールバックで取得して、後続の処理につなげる方法だが、Promiseの解決方法は非同期処理の結果ではなく代わりにPromiseオブジェクトを返し処理が完了したら値を返す

```js
const fs = require('fs');

// 非同期処理を行い、Promiseを返却する関数を定義
function readFile(file) {
    return new Promise((resolve) => {
        fs.readFile(file, 'utf-8', (err, data) => {
            resolve(data)
        })
    })
}

readFile('data_001.json')
    .then((data) => {
        console.log(data);
        return readFile('data_002.json');
    })
    .then((data) => {
        console.log(data);
        return readFile('data_003.json');
    })
    .then((data) => {
        console.log(data);
    })
```

**結果**

```js
$ node promise.js
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
{
    "id": "3",
    "name": "steve"
}
```

`(処理).then(()=>{次の処理}`と繋ぐ必要がある

#### async/awaitによる実装

非同期処理で後続の実行を待たせたいときはawaitを関数を呼び出す前につける必要があり、また、awaitを使う関数にはasyncの記述する必要がある

```js
const fs = require('fs');

// 非同期処理を行い、Promiseを返却する関数を定義
function readFile(file) {
    return new Promise((resolve) => {
        fs.readFile(file, 'utf-8', (err, data) => {
            resolve(data)
        })
    })
}

async function readFiles() {
    data001 = await readFile('data_001.json');
    console.log(data001);
    data002 = await readFile('data_002.json');
    console.log(data002);
    data003 = await readFile('data_003.json');
    console.log(data003);
}

readFiles();
```

**結果**

```js
$ node async.await.js
{
    "id": "1",
    "name": "bob"
}
{
    "id": "2",
    "name": "john"
}
{
    "id": "3",
    "name": "steve"
}
```

触れてみないとわからない

### [「ソースコード全部読まなきゃ病」と闘う方法 \- Qiita](https://qiita.com/guitar_char/items/3b31f7cc79333120b452)

- ソースを全部読まない読み方
  - Facedeを読む
    - 一番使う回数の多いところ周辺から徐々に理解していく
  - 必要なところだけ読む
    - 今知りたい知識が理解できたらそれより深く読まない、疑問が止まらない対象が出てきたら読む

こういう読み方があるんだ

## 02

### [PHPのintの最大値を超えた場合の挙動はどうなるか？ \- Qiita](https://qiita.com/a-nishimura/items/ce7d51202cc0a3eb38ec)

- intの最大値は32bitは約21億、64bitは約900京
- intの最大値を超えたらfloatになる

64bit

```php
$int_test = 9223372036854775807;
var_dump($int_test);
$int_test = 9223372036854775808;
var_dump($int_test);
```

**結果**

```php
int(9223372036854775807)
float(9.2233720368548E+18)
```

オーバーフローした値をintにキャストすると

```php
$int_test = (int)9223372036854775808;
var_dump($int_test);
```

**結果**

```php
int(-9223372036854775808)
```

`php_int_min`のintの最小値になった

オーバーフローするほどの値を扱うことがあるのだろうか？

### [Laravel View表示におけるview\(\)とredirect\(\)の違いについて \- Qiita](https://qiita.com/kajihara-kenji/items/3fe6c589d744a46912ae)

- view()は直接ファイルを呼び出す
- redirect()はRouteに沿ってViewを表示する

```php
Route::get('test-redirect', function () {
    return redirect('profile/index');
});

    /*上記、redirect('profile/index')から
        下記、get引数の'profile/index'へ*/

Route::get('profile/index', function () {
    return view('profile.index'); 
});
```

備忘録として残しておこう