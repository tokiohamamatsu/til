# 2019-12

## 02

### [おれがコンピュータに筆算を教えてやる \- 「100 桁の足し算」編 \- Qiita](https://qiita.com/noritakaIzumi/items/7b95852c3d5cc626c7b7)

普通に100桁の足し算をすると結果的にfloat型の値が出て、正確に出てこない

コンピューターに筆算させる

```php
function addBigInt(string $a, string $b): string
{
    // 自然数を受け取る
    $reversedDigit1 = array_reverse(str_split($a));
    $reversedDigit2 = array_reverse(str_split($b));
    $reversedSumDigit = array_fill(
        0,
        /* 足す数のうち，大きい方の桁数 */ max(count($reversedDigit1), count($reversedDigit2)),
        /* 0 で埋めた配列 */ 0
    );


    // 各位の足し算をする
    $carryOver = 0; // 繰り上がりの数字 (2 つの数の足し算なら必ず 0 or 1)
    foreach ($reversedSumDigit as $power => $digit) {
        // 直接要素をいじりたいので， $reversedSumDigit[$power] を変数化しない
        $reversedSumDigit[$power] += $carryOver;
        $carryOver = 0;

        $reversedSumDigit[$power] += $reversedDigit1[$power] + $reversedDigit2[$power];
        if ($reversedSumDigit[$power] >= 10) {
            $carryOver += floor($reversedSumDigit[$power] / 10);
            $reversedSumDigit[$power] %= 10;
        }
    }

    // 最後の桁の繰り上がりを考慮
    if ($carryOver > 0) {
        $reversedSumDigit[] = $carryOver;
    }

    // 再び逆順にすれば答えになる
    return implode(array_reverse($reversedSumDigit));
}
```

implodeは配列要素を文字列により連結する
[PHP: implode \- Manual](https://www.php.net/manual/ja/function.implode.php)

int型は最大19桁

```php
var_dump(PHP_INT_MAX); // int(9223372036854775807)
```

なので、文字数として受け取る。

```php
function addBigInt(string $a, string $b): string
{
    return '';
}
```

筆算は1の位から順に行うので、受け取った文字列を逆順で配列に収める

```php
// 自然数を受け取る
$reversedDigit1 = array_reverse(str_split($a));
$reversedDigit2 = array_reverse(str_split($b));
```

逆数に収めておくと、配列のインデックス番号が10の累乗部分そのものになる

```php
// 各位の足し算をする
$carryOver = 0; // 繰り上がりの数字 (2 つの数の足し算なら必ず 0 or 1)
foreach ($reversedSumDigit as $power => $digit) {
    // 直接要素をいじりたいので， $reversedSumDigit[$power] を変数化しない
    $reversedSumDigit[$power] += $carryOver;
    $carryOver = 0;
    $reversedSumDigit[$power] += $reversedDigit1[$power] + $reversedDigit2[$power];
    if ($reversedSumDigit[$power] >= 10) {
        $carryOver += floor($reversedSumDigit[$power] / 10);
        $reversedSumDigit[$power] %= 10;
    }
}

// 最後の桁の繰り上がりを考慮
if ($carryOver > 0) {
    $reversedSumDigit[] = $carryOver;
}
```

数値が逆順なので、元に戻す

```Php
// 再び逆順にすれば答えになる
return implode(array_reverse($reversedSumDigit));
```

array_reverse要素を逆順にした配列を返す。
[PHP: array\_reverse \- Manual](https://www.php.net/manual/ja/function.array-reverse.php)

## 03 

### [libphonenumberで国際電話番号をバリデーション \- Qiita](https://qiita.com/nagahama/items/07f723467b55050dd9d3)

javascript

国際電話番号のバリデーション

libphonenumberを使う

https://qiita.com/the_red/items/fcedd5033530b7ff7ee7

```js
var internationalCallCheck = function (value) {
  return libphonenumber.isValidNumber(value)
}

internationalCallCheck('+81928321133'); // true
internationalCallCheck('+87928321133'); // false +87の国番号は存在しない
```

isValidNumberの第2引数に['jp']など国を識別するコードを渡すと、国番号を省略した場合のバリデーションが有効になる。

```js
libphonenumber.isValidNumber('0928321133') // false

libphonenumber.isValidNumber('0928321133', 'JP') // true
libphonenumber.isValidNumber('0928321133', 'CN') // false
```

isValidNumberはハイフンが適切な箇所に入ってない場合でもバリデーションを通す。

asYouType()を使ってフォーマットすることで区切られた電話番号が取得できる。

```js
var internationalCallFormat = function (value) {
  return new libphonenumber.AsYouType().input(value);
}

internationalCallFormat('+819--2----8321--133'); // '+81 92 832 1133
```

## 04

### [PHPで週を扱う場合の注意点（ISO8601） \- Qiita](https://qiita.com/moritahiroo/items/5553f1e2feceb270f3c6)

2018年の12月最終週

| 日  | 月  | 火  | 水  | 木  | 金  | 土  |
| --- | --- | --- | --- | --- | --- | --- |
| 30  | 31  | 1   | 2   | 3   | 4   | 5   |

2018年12月30日と2018年12月31日は何週目かを表示する

```php
echo (new \DateTime('2018-12-30 00:00:00'))->format('W');

//52
```

2018年12月30日は52週目

```php
echo (new \DateTime('2018-12-31 00:00:00'))->format('W');

//01
```

2018年12/31日は1週目になる

これは、ISO8601に基づいているためこうなるらしい

[ISO 8601 \- Wikipedia](https://ja.wikipedia.org/wiki/ISO_8601#%E5%B9%B4%E3%81%A8%E9%80%B1%E3%81%A8%E6%9B%9C%E6%97%A5)

同様に2018年1月1日は1周目ではなく52週目になる

## 05

### [Vue Composition APIで型がぶっ壊れて楽しかったです \- Qiita](https://qiita.com/merotan/items/fa31f7242e6888538259)

```js
export default createComponent({
  setup () {
    const state = reactive({
      status: 'hoge',
      value: 'fuga'
    });
    const v = state.value;
  }
});
```

上記のようなコードでstateは

```js
type State = {
  status: string;
  value: string;
}
```

と期待しているが、VSCode等で見るとstateはstringになる

どのように型定義されているのか

```js
export function reactive<T = any>(obj: T): UnwrapRef<T> {
  if (process.env.NODE_ENV !== 'production' && !obj) {
    warn('"reactive()" is called without provide an "object".');
    // @ts-ignore
    return;
  }

  if (!isPlainObject(obj) || isReactive(obj) || isNonReactive(obj) || !Object.isExtensible(obj)) {
    return obj as any;
  }

  const observed = observe(obj);
  def(observed, ReactiveIdentifierKey, ReactiveIdentifier);
  setupAccessControl(observed);
  return observed as UnwrapRef<T>;
}
```

isPlainObjectは引数がobjectか動かをチェックする。
[jQuery リファレンス：jQuery\.isPlainObject](http://www.jquerystudy.info/reference/utilities/isPlainObject.html)

Object.isExtensibleはオブジェクトを拡張可能であるかどうかを決定する
[Object\.isExtensible\(\) \- JavaScript \| MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)

`UnwrapRef<T>`

```js
export type UnwrapRef<T> = T extends Ref<infer V>
  ? UnwrapRef2<V>
  : T extends BailTypes
      ? T // bail out on types that shouldn’t be unwrapped
      : T extends object ? { [K in keyof T]: UnwrapRef2<T[K]> } : T

// prettier-ignore
type UnwrapRef2<T> = T extends Ref<infer V>
  ? UnwrapRef3<V>
  : T extends BailTypes
      ? T
      : T extends object ? { [K in keyof T]: UnwrapRef3<T[K]> } : T


// ...

// prettier-ignore
type UnwrapRef10<T> = T extends Ref<infer V>
  ? V // stop recursion
  : T 
```

ConditionalTypesを使って型を判定している。

ConditionalTypes

[Advanced Types · TypeScript](http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types)

[TypeScript 2\.8 の Conditional Types について \- Qiita](https://qiita.com/Quramy/items/b45711789605ef9f96de)

Ref

```js
export interface Ref<T> {
  value: T;
}
```

valueをメンバーとして持っている場合は、RefをextendしているとみなされUnwrapRef2 UnwrapRef3 ．．．と流されていき、最終的にUwrapRef10にたどり着きVとなる。

objectの中にobjectがあったりすると同様な問題が起きる。

## 06

### [オブジェクト操作のすゝめ \(map,forEachとかが便利すぎる話\) \- Qiita](https://qiita.com/HiraginoYuki/items/123689e8c6c067b46171)

javascriptの型標準メソッド

foreach() 返り値:undefined
map() 返り値: callbackの返り値を含む新しい配列
filter() 返り値:callbackの返り値がtruthyだったものだけを含む新しい配列
some() 返り値:callbackの返り値のどれかがtruthyだったっ場合にture,そうでない場合はfalse

truthyはBooleanコンキストに現れた時にtrueとみなされる値
[Truthy \- MDN Web Docs 用語集: ウェブ関連用語の定義 \| MDN](https://developer.mozilla.org/ja/docs/Glossary/Truthy)

具体例

idをキーに、idのあるエレメントだけを含むオブジェクトを作成

```js
let elems = new (
  function() {
    [...document.querySelectorAll("*")]
      .filter (element => element.id)
      .forEach(element => this[element.id] = element)
  }
)();
```

document.querySelectorAll()で`*`を指定しページ上の全てのエレメントを取得するが、このままだとarraylikeObjectと呼ばされる、配列の似ただのオブジェクトのため、スプレッド構文を使い配列に変換する

```js
let array;

array = [...arrayLikeObject];

// 別の書き方
array = Array(...arrayLikeObject);
array = Array.from(arrayLikeObject);
array = new Array(...arrayLikeObject);
```

idを持ったエレメントだけを取り出すために、filter()を使い、それをthisに書き出す。

```js
let elems=new(function(){[...document.querySelectorAll("*")].filter(e=>e.id).forEach(e=>this[e.id]=e)})();
```

結果をthisに書き出すためにnewと即時関数を組み合すことで、返り値をthisというオブジェクトとして扱え、returnされるオブジェクトを格納するための変数を宣言しなくてもいい

アロー関数を使うとグローバルオブジェクトのthisをそのまま継承する。

## 09

### [LaravelのAPIテストを簡単に書いて実行しよう！ \- Qiita](https://qiita.com/NARI_Creator/items/fc3c74c2065169b15f5c)

目的：APIのテストケースを実装する。

基礎クラスを作り、それを継承したテストクラスを実装する

基礎クラス(ApiTestBase.php)

テストクラス(PostApiControllerTest.php)

コマンドで上記をテストする
```
vendor/bin/phpunit tests/Feature/PostApiControllerTest.php
```

実行したくないテストがある場合はApiTestBase.phpにあるフラグをfalseにすればテストは実行されない。

ApiTestBase.phpにあるdoAssertResponseをoverrideしてresponseの中身をチェックできる。(getのみ対応しているため、insert、updateで必要な場合は個別に実装する必要がある。)

## 10

### [InternetExplorerを拒否するサイトの作り方 \- Qiita](https://qiita.com/Robot-Inventor/items/1662bc4450e0183e07fc)

InternetExplorerを判定

`window.navigator.userAgent`を使いnavigatorオブジェクトを取得する。navigatorオブジェクトはブラウザに関する情報を持つ

`window.navigator.userAgent`に`.toLowerCase()`をつけ文字列を小文字に変換し、その後に`indexOf()`の引数にブラウザの識別子を入れ判定する。
`indexOf()`は見つからない時-1を返す。

InternetExplorerの識別子はmsie、IE11からtrident

```js
var userAgent = window.navigator.userAgent.toLowerCase();
if(userAgent.indexOf('msie') != -1 ||
    userAgent.indexOf('trident') != -1) {
        window.location.replace("do_not_use_ie.html");
}
```

ブラウザの識別子  [使用してるブラウザを判定したい \- Qiita](https://qiita.com/sakuraya/items/33f93e19438d0694a91d#%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%AE%E8%AD%98%E5%88%A5%E5%AD%90)


## 11

### [【Composition API】StoreパターンでVuexを使わずに状態管理をする \- Qiita](https://qiita.com/chan_kaku/items/b51e12ebfae6346fbad2)

導入

Compostion APIをVue2.xでも使える@vue/composition-apiを入れる

```
$ yarn add @vue/composition-api
```

使う場所に下記を追加

```js
import VueCompositionApi from '@vue/composition-api';// 追加した箇所
Vue.use(VueCompositionApi);// 追加した箇所
```

状態の管理

storeパッケージの配下にjsファイルを作成する

```js
export let store = {
    state: {
        message: 'this is first message'
    },
    getMessage() {
        return this.state.message
    },
    setMessage(newVal) {
        this.state.message = newVal
    }
}
```
```js
import { reactive, onMounted } from '@vue/composition-api'
import { store } from '@/store/store.js' //作成したjsファイル

export default {
  name: 'HelloWorld',
  setup() {
    onMounted(() => {
      getMessage()
    })

    const state = reactive({
      privateMessage: '',
      globalMessage: ''
    })

    function getMessage() {
      state.globalMessage = store.getMessage()
    }

    function setMessage() {
      store.setMessage(state.privateMessage)
    }

    return {
      state,
      getMessage,
      setMessage
    }
  }
}
```

Composition APIは基本的にsetup()内で使っていく


わからなかった事

- Store
- Composition API
- setup
- vue.observable

上記の意味がわからず記事の説明がわからないため、上記を後日調べる

## 12

### [JavaScript、許されざる呪文 \- Qiita](https://qiita.com/K_Hisui/items/805b0fad39929f300217)

document.writeはjavascriptで標準的に備わっている関数

変数を代入した後に関数を使用するとエラーになる

```js
document.write = "Crucio";
console.log(document.write); //Crucio
document.write("Crucio"); //Uncaught TypeError: document.write is not a function
```

関数にユーザー定義を代入したら通るようになる

```js
function hoge(text) {
    console.log(text);
}
document.write = hoge;
document.write("Crucio"); //Crucio
```

javascriptはユーザー定義関数であれば関数内のコードを出力できる。(デフォルトの関数は無理)

```js
console.log(console.log);
/* ƒ log() { [native code] } */
```

なぜにdocument.writeに値を代入できるんだろ？

## 13

### [仮想DOMってすげーんだぜ！ \- Qiita](https://qiita.com/Gsann/items/e8ca34f5b7bdab4fde11)

仮想DOMはJavascriptのオブジェクト

リアルDOMを仮想的に作り、仮想DOMを2つ用意し、片方のDOMを操作、変更前と比べその差分をリアルDOMに反映する。

仮想DOMはレンダリングコストが低い

リアルDOMの操作

```js
<div id="app">
  <p id="counter">0</p>
  <button type="button" id="increment">+1</button>    
</div>

<script>
const state = { count: 0 };
const btn = document.getElementById('increment');
btn.addEventListener('click', () => {
  const counter = document.getElementById('counter');
  counter.innerText = ++state.count;
})
</script>
```

仮想DOMをVue.jsを使い操作

```js
<template>
  <div>
    <p>{{ count }}</p>
    <button v-on:click="increment">+1</button>
  </div>
</template>

<script>
new Vue({
  data: {
    count: 0
  },
  methods: {
    increment: function() {
      this.count += 1
    }
  }
})
</script>
```