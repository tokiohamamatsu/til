# 2019-12

## 02

### [おれがコンピュータに筆算を教えてやる \- 「100 桁の足し算」編 \- Qiita](https://qiita.com/noritakaIzumi/items/7b95852c3d5cc626c7b7)

普通に100桁の足し算をすると結果的にfloat型の値が出て、正確に出てこない

コンピューターに筆算させる

```php
function addBigInt(string $a, string $b): string
{
    // 自然数を受け取る
    $reversedDigit1 = array_reverse(str_split($a));
    $reversedDigit2 = array_reverse(str_split($b));
    $reversedSumDigit = array_fill(
        0,
        /* 足す数のうち，大きい方の桁数 */ max(count($reversedDigit1), count($reversedDigit2)),
        /* 0 で埋めた配列 */ 0
    );


    // 各位の足し算をする
    $carryOver = 0; // 繰り上がりの数字 (2 つの数の足し算なら必ず 0 or 1)
    foreach ($reversedSumDigit as $power => $digit) {
        // 直接要素をいじりたいので， $reversedSumDigit[$power] を変数化しない
        $reversedSumDigit[$power] += $carryOver;
        $carryOver = 0;

        $reversedSumDigit[$power] += $reversedDigit1[$power] + $reversedDigit2[$power];
        if ($reversedSumDigit[$power] >= 10) {
            $carryOver += floor($reversedSumDigit[$power] / 10);
            $reversedSumDigit[$power] %= 10;
        }
    }

    // 最後の桁の繰り上がりを考慮
    if ($carryOver > 0) {
        $reversedSumDigit[] = $carryOver;
    }

    // 再び逆順にすれば答えになる
    return implode(array_reverse($reversedSumDigit));
}
```

implodeは配列要素を文字列により連結する
[PHP: implode \- Manual](https://www.php.net/manual/ja/function.implode.php)

int型は最大19桁

```php
var_dump(PHP_INT_MAX); // int(9223372036854775807)
```

なので、文字数として受け取る。

```php
function addBigInt(string $a, string $b): string
{
    return '';
}
```

筆算は1の位から順に行うので、受け取った文字列を逆順で配列に収める

```php
// 自然数を受け取る
$reversedDigit1 = array_reverse(str_split($a));
$reversedDigit2 = array_reverse(str_split($b));
```

逆数に収めておくと、配列のインデックス番号が10の累乗部分そのものになる

```php
// 各位の足し算をする
$carryOver = 0; // 繰り上がりの数字 (2 つの数の足し算なら必ず 0 or 1)
foreach ($reversedSumDigit as $power => $digit) {
    // 直接要素をいじりたいので， $reversedSumDigit[$power] を変数化しない
    $reversedSumDigit[$power] += $carryOver;
    $carryOver = 0;
    $reversedSumDigit[$power] += $reversedDigit1[$power] + $reversedDigit2[$power];
    if ($reversedSumDigit[$power] >= 10) {
        $carryOver += floor($reversedSumDigit[$power] / 10);
        $reversedSumDigit[$power] %= 10;
    }
}

// 最後の桁の繰り上がりを考慮
if ($carryOver > 0) {
    $reversedSumDigit[] = $carryOver;
}
```

数値が逆順なので、元に戻す

```Php
// 再び逆順にすれば答えになる
return implode(array_reverse($reversedSumDigit));
```

array_reverse要素を逆順にした配列を返す。
[PHP: array\_reverse \- Manual](https://www.php.net/manual/ja/function.array-reverse.php)

## 03 

### [libphonenumberで国際電話番号をバリデーション \- Qiita](https://qiita.com/nagahama/items/07f723467b55050dd9d3)

javascript

国際電話番号のバリデーション

libphonenumberを使う

https://qiita.com/the_red/items/fcedd5033530b7ff7ee7

```js
var internationalCallCheck = function (value) {
  return libphonenumber.isValidNumber(value)
}

internationalCallCheck('+81928321133'); // true
internationalCallCheck('+87928321133'); // false +87の国番号は存在しない
```

isValidNumberの第2引数に['jp']など国を識別するコードを渡すと、国番号を省略した場合のバリデーションが有効になる。

```js
libphonenumber.isValidNumber('0928321133') // false

libphonenumber.isValidNumber('0928321133', 'JP') // true
libphonenumber.isValidNumber('0928321133', 'CN') // false
```

isValidNumberはハイフンが適切な箇所に入ってない場合でもバリデーションを通す。

asYouType()を使ってフォーマットすることで区切られた電話番号が取得できる。

```js
var internationalCallFormat = function (value) {
  return new libphonenumber.AsYouType().input(value);
}

internationalCallFormat('+819--2----8321--133'); // '+81 92 832 1133
```

## 04

### [PHPで週を扱う場合の注意点（ISO8601） \- Qiita](https://qiita.com/moritahiroo/items/5553f1e2feceb270f3c6)

2018年の12月最終週

| 日  | 月  | 火  | 水  | 木  | 金  | 土  |
| --- | --- | --- | --- | --- | --- | --- |
| 30  | 31  | 1   | 2   | 3   | 4   | 5   |

2018年12月30日と2018年12月31日は何週目かを表示する

```php
echo (new \DateTime('2018-12-30 00:00:00'))->format('W');

//52
```

2018年12月30日は52週目

```php
echo (new \DateTime('2018-12-31 00:00:00'))->format('W');

//01
```

2018年12/31日は1週目になる

これは、ISO8601に基づいているためこうなるらしい

[ISO 8601 \- Wikipedia](https://ja.wikipedia.org/wiki/ISO_8601#%E5%B9%B4%E3%81%A8%E9%80%B1%E3%81%A8%E6%9B%9C%E6%97%A5)

同様に2018年1月1日は1周目ではなく52週目になる

## 05

### [Vue Composition APIで型がぶっ壊れて楽しかったです \- Qiita](https://qiita.com/merotan/items/fa31f7242e6888538259)

```js
export default createComponent({
  setup () {
    const state = reactive({
      status: 'hoge',
      value: 'fuga'
    });
    const v = state.value;
  }
});
```

上記のようなコードでstateは

```js
type State = {
  status: string;
  value: string;
}
```

と期待しているが、VSCode等で見るとstateはstringになる

どのように型定義されているのか

```js
export function reactive<T = any>(obj: T): UnwrapRef<T> {
  if (process.env.NODE_ENV !== 'production' && !obj) {
    warn('"reactive()" is called without provide an "object".');
    // @ts-ignore
    return;
  }

  if (!isPlainObject(obj) || isReactive(obj) || isNonReactive(obj) || !Object.isExtensible(obj)) {
    return obj as any;
  }

  const observed = observe(obj);
  def(observed, ReactiveIdentifierKey, ReactiveIdentifier);
  setupAccessControl(observed);
  return observed as UnwrapRef<T>;
}
```

isPlainObjectは引数がobjectか動かをチェックする。
[jQuery リファレンス：jQuery\.isPlainObject](http://www.jquerystudy.info/reference/utilities/isPlainObject.html)

Object.isExtensibleはオブジェクトを拡張可能であるかどうかを決定する
[Object\.isExtensible\(\) \- JavaScript \| MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)

`UnwrapRef<T>`

```js
export type UnwrapRef<T> = T extends Ref<infer V>
  ? UnwrapRef2<V>
  : T extends BailTypes
      ? T // bail out on types that shouldn’t be unwrapped
      : T extends object ? { [K in keyof T]: UnwrapRef2<T[K]> } : T

// prettier-ignore
type UnwrapRef2<T> = T extends Ref<infer V>
  ? UnwrapRef3<V>
  : T extends BailTypes
      ? T
      : T extends object ? { [K in keyof T]: UnwrapRef3<T[K]> } : T


// ...

// prettier-ignore
type UnwrapRef10<T> = T extends Ref<infer V>
  ? V // stop recursion
  : T 
```

ConditionalTypesを使って型を判定している。

ConditionalTypes

[Advanced Types · TypeScript](http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types)

[TypeScript 2\.8 の Conditional Types について \- Qiita](https://qiita.com/Quramy/items/b45711789605ef9f96de)

Ref

```js
export interface Ref<T> {
  value: T;
}
```

valueをメンバーとして持っている場合は、RefをextendしているとみなされUnwrapRef2 UnwrapRef3 ．．．と流されていき、最終的にUwrapRef10にたどり着きVとなる。

objectの中にobjectがあったりすると同様な問題が起きる。

## 06

### [オブジェクト操作のすゝめ \(map,forEachとかが便利すぎる話\) \- Qiita](https://qiita.com/HiraginoYuki/items/123689e8c6c067b46171)

javascriptの型標準メソッド

foreach() 返り値:undefined
map() 返り値: callbackの返り値を含む新しい配列
filter() 返り値:callbackの返り値がtruthyだったものだけを含む新しい配列
some() 返り値:callbackの返り値のどれかがtruthyだったっ場合にture,そうでない場合はfalse

truthyはBooleanコンキストに現れた時にtrueとみなされる値
[Truthy \- MDN Web Docs 用語集: ウェブ関連用語の定義 \| MDN](https://developer.mozilla.org/ja/docs/Glossary/Truthy)

具体例

idをキーに、idのあるエレメントだけを含むオブジェクトを作成

```js
let elems = new (
  function() {
    [...document.querySelectorAll("*")]
      .filter (element => element.id)
      .forEach(element => this[element.id] = element)
  }
)();
```

document.querySelectorAll()で`*`を指定しページ上の全てのエレメントを取得するが、このままだとarraylikeObjectと呼ばされる、配列の似ただのオブジェクトのため、スプレッド構文を使い配列に変換する

```js
let array;

array = [...arrayLikeObject];

// 別の書き方
array = Array(...arrayLikeObject);
array = Array.from(arrayLikeObject);
array = new Array(...arrayLikeObject);
```

idを持ったエレメントだけを取り出すために、filter()を使い、それをthisに書き出す。

```js
let elems=new(function(){[...document.querySelectorAll("*")].filter(e=>e.id).forEach(e=>this[e.id]=e)})();
```

結果をthisに書き出すためにnewと即時関数を組み合すことで、返り値をthisというオブジェクトとして扱え、returnされるオブジェクトを格納するための変数を宣言しなくてもいい

アロー関数を使うとグローバルオブジェクトのthisをそのまま継承する。